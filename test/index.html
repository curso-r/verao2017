<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="pt-br">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <meta name="google-site-verification" content="3wpHHnuvp_52dDrXvZoNa5_Vs4BWcyVoeM62GbQ7llc" />
    <title> - Curso-R</title>
    <meta name="generator" content="Hugo 0.17" />

    
    <meta name="description" content="Materiais para o Curso-R de verão 2017">
    
    <link rel="canonical" href="../test/">
    
    <meta name="author" content="Curso-R">
    

    <meta property="og:url" content="/test/">
    <meta property="og:title" content="Curso-R">
    <meta property="og:image" content="/logo-curso-r.png">
    <meta name="apple-mobile-web-app-title" content="Curso-R">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="//images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="//images/favicon.ico">
    <link rel="stylesheet" href="../stylesheets/icons.css">
    <link rel="stylesheet" href="../stylesheets/application.css">
    <link rel="stylesheet" href="../stylesheets/temporary.css">
    <link rel="stylesheet" href="../stylesheets/palettes.css">
    <link rel="stylesheet" href="../stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu&#43;Mono">
    <style>
      body, input {
        font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="../javascripts/modernizr.js"></script>

    

  </head>
  <body class="palette-primary-red palette-accent-teal">



	
	


<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        
      </div>
    </div>

    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/curso-r" title="@curso-r on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="https://github.com/curso-r/verao2017" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="../logo-curso-r.png">
        </div>
      
      <div class="name">
        <strong>Curso-R </strong>
        
          <br>
          curso-r/verao2017
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      
        <ul class="repo">
          <li class="repo-download">
            <a href="https://github.com/curso-r/verao2017/archive/master.zip" target="_blank" title="Download" data-action="download">
              <i class="icon icon-download"></i> Download
            </a>
          </li>
          <li class="repo-stars">
            <a href="https://github.com/curso-r/verao2017/stargazers" target="_blank" title="Stargazers" data-action="star">
              <i class="icon icon-star"></i> Stars
              <span class="count">&ndash;</span>
            </a>
          </li>
        </ul>
        <hr>
      

      <div class="toc">
        
        <ul>
          




<li>
  
    



<a  title="Curso R" href="../">
	
	Curso R
</a>



  
</li>



<li>
  
    



<a  title="R como calculadora" href="../rbase/">
	
	R como calculadora
</a>



  
</li>



<li>
  
    



<a  title="Visualização" href="../ggplot/">
	
	Visualização
</a>



  
</li>



<li>
  
    



<a  title="Transformação" href="../manip/">
	
	Transformação
</a>



  
</li>



<li>
  
    



<a  title="Stringr" href="../stringr/">
	
	Stringr
</a>



  
</li>


        </ul>
        

        
        <hr>
        <span class="section">The author</span>
        
        <ul>
          

          
          <li>
            <a href="https://github.com/curso-r" target="_blank" title="@curso-r on GitHub">
              @curso-r on GitHub
            </a>
          </li>
          

          
          <li>
            <a href="mailto:dfalbel@gmail.com" title="Email of dfalbel@gmail.com">
              Contact via email
            </a>
          </li>
          
        </ul>
        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1> </h1>

			/BLOGDOWN-BODY-BEFORE -->

<div id="introducao-stringr" class="section level1">
<h1>Introdução: Stringr</h1>
<p>Variáveis do tipo texto são muito comuns nos bancos de dados e geralmente são colunas que dão bastante trabalho para serem manipuladas. É muito comun encontrar bancos de dados em que os textos de uma coluna não estão padronizados, por exemplo uma coluna <code>Estado</code> em que são encontrados “SP”, “sp”, “Sao Paulo”, “São Paulo”, etc todas as variações indicando o mesmo estado.</p>
<p>Para manipular esses textos o R possui diversas funções para manipular textos, no entanto, as funções do <code>base</code> não possuem um interface consistente e parece que cada uma tem a sua forma de passar os parâmetros, dificultando o processo durante a análise.</p>
<p>Por isso, é recomendado usar o pacote <code>stringr</code> que possui a sintaxe consistente permitindo que o usuário realize qualquer manipulação com textos com maior facilidade.</p>
<div id="vantagens-do-stringr-em-relacao-ao-base" class="section level2">
<h2>Vantagens do stringr em relação ao base</h2>
<ul>
<li>Sintaxe unificada, o que auxilia na memorização e leitura do código.</li>
<li>Todas as funções são vetorizadas.</li>
<li>Construído sobre a <a href="http://site.icu-project.org/">biblioteca ICU</a>, implementada em <code>C</code> e <code>C++</code>, apresentando resultados rápidos e confiáveis.</li>
</ul>
</div>
<div id="regras-basicas-do-pacote" class="section level2">
<h2>Regras básicas do pacote</h2>
<ul>
<li>As funções de manipulação de texto começam com <code>str_</code>. Caso esqueça o nome de uma função, basta digitar <code>stringr::str_</code> e apertar <code>TAB</code> para ver quais são as opções.</li>
<li>O primeiro argumento da função é sempre uma <code>string</code> ou um vetor de <code>strings</code>.</li>
</ul>
</div>
<div id="curiosidade" class="section level2">
<h2>Curiosidade</h2>
<p>Inicialmente, o <code>stringr</code> era um <em>wrapper</em> de funções do <code>base</code>. Depois disso, surgiu um novo pacote <code>stringi</code>, com sintaxe similar ao <code>stringr</code>, mas funcionando como <em>wrapper</em> da biblioteca ICU. No entanto, Wickham gostou tanto do pacote <code>stringi</code> que decidiu reescrever o <code>stringr</code> como um <em>wrapper</em> do <code>stringi</code>. Veja <a href="https://github.com/tidyverse/stringr/blob/master/NEWS.md">essa página</a> para detalhes. #stringr: Básico #### str_to_upper, str_to_lower, str_to_title #str_to_title(s)</p>
<p>Todas as funções do <code>stringr</code> começam com o prefixo <code>str</code>, isso ajuda na hora de encontrar a função que você está procurando. No Rstudio, basta digitar <code>str_</code> e apertar tab que você verá algo parecido com a imagem a baixo. Você pode ir descendo com as setas do teclado e ver o que cada função faz até encontrar a função que estava procurando.</p>
<div class="figure">
<img src="../home/travis/build/azeloc/pu.test/figure/str_tab.png" alt="str_tab" />
<p class="caption">str_tab</p>
</div>
<p>Nesta sessão vamos utilizar as funções mais simples do <code>stringr</code>, depois vamos ensinar um pouco de Regex e em seguida veremos as funções mais avançadas do pacote.</p>
</div>
<div id="funcoes-basicas" class="section level2">
<h2>Funções básicas</h2>
<div id="str_length" class="section level3">
<h3>str_length</h3>
<p>A função mais simples do <code>stringr</code> é a função <code>str_length</code>. Esta função recebe apenas uma string como argumento e retorna o número de caracteres. Por exemplo:</p>
<pre class="r"><code>library(stringr)
str_length(&quot;olá&quot;)</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code>length(&quot;olá&quot;)</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Veja <code>str_length</code> é diferente de <code>length</code>. O primeiro retorna o número de caracteres e o segundo retorna o comprimento do objeto. Isso fica mais claro no seguinte exemplo:</p>
<pre class="r"><code>s &lt;- c(&quot;olá mundo&quot;, &quot;olá universo&quot;)
str_length(s)</code></pre>
<pre><code>## [1]  9 12</code></pre>
<pre class="r"><code>length(s)</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Agora o <code>str_length</code> retornou um vetor com o número de caracteres de cada elemento do vetor <code>s</code>, e o <code>length</code> retornou o comprimento do vetor <code>s</code>. Note que espaço é considerado como um caractere.</p>
</div>
<div id="str_trim" class="section level3">
<h3>str_trim</h3>
<p>É muito comum encontrar textos que vêm com espaços a mais, principalmente de dados provenientes de formulários em que cada usuário escreve da forma que prefere.</p>
<pre class="r"><code>string &lt;- &#39;\nessa      string é muito suja       \n&#39;
str_trim(string)</code></pre>
<pre><code>## [1] &quot;essa      string é muito suja&quot;</code></pre>
<p>A função <code>str_trim</code> ajuda removendo os espaços excedetes antes e depois da string.</p>
</div>
<div id="str_sub" class="section level3">
<h3>str_sub</h3>
<p>As vezes você precisa obter alguma parte fixa de uma string. Por exemplo, as vezes você encontra variáveis com valores da forma:</p>
<pre class="r"><code>s &lt;- c(&quot;01-Feminino&quot;, &quot;02-Masculino&quot;, &quot;03-Indefinido&quot;)</code></pre>
<p>Você pode querer manipular essa string para retirar obter apenas a parte final da string. Neste caso pode usar a função <code>str_sub</code></p>
<pre class="r"><code>str_sub(s, start = 4) # pegar do quarto até o último caractere</code></pre>
<pre><code>## [1] &quot;Feminino&quot;   &quot;Masculino&quot;  &quot;Indefinido&quot;</code></pre>
<p>É possível obter também apenas os números</p>
<pre class="r"><code>str_sub(s, end = 2) # pegar apenas os dois primeiros caracteres</code></pre>
<pre><code>## [1] &quot;01&quot; &quot;02&quot; &quot;03&quot;</code></pre>
<p>Em outros casos você precisa obter os últimos 2 caracteres.</p>
<pre class="r"><code>s &lt;- c(&quot;Feminino-01&quot;, &quot;Masculino-02&quot;, &quot;Indefinido-03&quot;)
str_sub(s, end = -4)</code></pre>
<pre><code>## [1] &quot;Feminino&quot;   &quot;Masculino&quot;  &quot;Indefinido&quot;</code></pre>
<pre class="r"><code>str_sub(s, start = -2)</code></pre>
<pre><code>## [1] &quot;01&quot; &quot;02&quot; &quot;03&quot;</code></pre>
<p>É possível também usar os argumentos <code>start</code> e <code>end</code> conjuntamente.</p>
<pre class="r"><code>s &lt;- c(&quot;__SP__&quot;, &quot;__MG__&quot;, &quot;__RJ__&quot;)
str_sub(s, 3, 4)</code></pre>
<pre><code>## [1] &quot;SP&quot; &quot;MG&quot; &quot;RJ&quot;</code></pre>
</div>
<div id="str_to_upper-str_to_lower-str_to_title" class="section level3">
<h3>str_to_upper, str_to_lower, str_to_title</h3>
<p>Essas funções servem para modificar a caixa das letras. Por exemplo:</p>
<pre class="r"><code>s &lt;- &quot;Olá, tudo bem?&quot;
str_to_lower(s)</code></pre>
<pre><code>## [1] &quot;olá, tudo bem?&quot;</code></pre>
<pre class="r"><code>str_to_upper(s)</code></pre>
<pre><code>## [1] &quot;OLÁ, TUDO BEM?&quot;</code></pre>
<pre class="r"><code>str_to_title(s)</code></pre>
<pre><code>## [1] &quot;Olá, Tudo Bem?&quot;</code></pre>
<p>Essas são as funções mais simples do pacote <code>stringr</code> e mão exigem nenhum conhecimento de regex. Note que nenhuma delas possui o parâmetro <code>pattern</code>, você verá como especificar esse parâmetros nas próximas sessões.</p>
</div>
</div>
</div>
<div id="regex" class="section level1">
<h1>Regex</h1>
<p>Trabalhar com textos exige um certo conhecimento de expressões regulares (<em>regex</em>). <a href="https://pt.wikipedia.org/wiki/Express%C3%A3o_regular">Expressões regulares</a> permitem identificar conjuntos de caracters, palavras, e outros padrões por meio de uma sintaxe concisa.</p>
<p>O <code>stringr</code> utiliza regex da forma descrita <a href="http://www.gagolewski.com/software/stringi/manual/?manpage=stringi-search-regex">neste documento</a>. A própria <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html">definição</a> de regex do R é um ótimo manual.</p>
<div id="expressoes-regulares" class="section level2">
<h2>Expressões regulares</h2>
<p>Expressão regular ou <em>regex</em> é uma sequência concisa de caracteres que representa várias strings. Entender o básico de expressões regulares é indispensável para trabalhar com textos.</p>
<p>Vamos estudar expressões regulares através de exemplos e com a função <code>str_detect()</code>. Essa função retorna <code>TRUE</code> se uma string atende à uma expressão regular e <code>FALSE</code> em caso contrário.</p>
<p>Por exemplo:</p>
<pre class="r"><code>library(stringr)
str_detect(&quot;sao paulo&quot;, pattern = &quot;paulo$&quot;)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>str_detect(&quot;sao paulo sp&quot;, pattern = &quot;paulo$&quot;)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>A regex/pattern “paulo<span class="math inline">\(&quot; indica que o texto deve ser terminado em &quot;paulo&quot;. Existem diversos de caracteres auxiliares que vão auxiliar na manipulação dos textos, assim como o &quot;\)</span>” neste caso. É importante notar que sempre que você estiver passando algum valor para o argumento <code>pattern</code> de qualquer função do <code>stringr</code> ele o entenderá como uma regex.</p>
<p>A tabela abaixo mostra a aplicação de seis <code>regex</code> a seis strings distintas.</p>
<pre class="r"><code>testes &lt;- c(&#39;ban&#39;, &#39;banana&#39;, &#39;abandonado&#39;, &#39;pranab anderson&#39;, &#39;BANANA&#39;, 
            &#39;ele levou ban&#39;)

expressoes &lt;- list(
  &#39;ban&#39;, # reconhece tudo que tenha &quot;ban&quot;, mas não ignora case
  &#39;BAN&#39;, # reconhece tudo que tenha &quot;BAN&quot;, mas não ignora case
  regex(&#39;ban&#39;, ignore_case = TRUE), # reconhece tudo que tenha &quot;ban&quot;, ignorando case
  &#39;ban$&#39;, # reconhece apenas o que termina exatamente em &quot;ban&quot;
  &#39;^ban&#39;, # reconhece apenas o que começa exatamente com &quot;ban&quot;
  &#39;b ?an&#39; # reconhece tudo que tenha &quot;ban&quot;, com ou sem espaço entre o &quot;b&quot; e o &quot;a&quot;
)</code></pre>
</div>
<div id="quantificadores" class="section level2">
<h2>Quantificadores</h2>
<p>Os caracteres <code>+</code>, <code>*</code> e <code>{x,y}</code> indicam quantas vezes um padrão se repete:</p>
<ul>
<li><code>ey+</code> significa <code>e</code> e depois <code>y</code> “<strong>uma vez</strong> ou mais”. Por exemplo, reconhece <code>hey</code>, <code>heyy</code>, <code>a eyyy</code>, mas não reconhece <code>e</code>, <code>y</code> nem <code>yy</code>.</li>
<li><code>ey*</code> significa “<strong>zero vezes</strong> ou mais”. Por exemplo, reconhece <code>hey</code>, <code>heyy</code>, <code>a eyyy</code> e <code>e</code>, mas não reconhece <code>y</code> nem <code>yy</code>.</li>
<li><code>ey{3}</code> significa “exatamente três vezes”. Por exemplo, reconhece <code>eyyy</code> e <code>eyyyy</code>, mas não reconhece <code>eyy</code>.</li>
<li><code>ey{1,3}</code> significa “entre uma e três vezes”.</li>
</ul>
<p>Para aplicar um quantificador a um conjunto de caracteres, use parênteses. Por exemplo, <code>(ey )+</code> reconhece <code>ey ey</code>.</p>
</div>
<div id="conjuntos" class="section level2">
<h2>Conjuntos</h2>
<p>Colocando caracteres dentro de <code>[]</code>, reconhecemos quaisquer caracteres desse conjunto. Alguns exemplos práticos:</p>
<ul>
<li><code>[Cc]asa</code> para reconhecer “casa” em maiúsculo ou minúsculo.</li>
<li><code>[0-9]</code> para reconhecer somente números. O mesmo vale para letras <code>[a-z]</code>, <code>[A-Z]</code>, <code>[a-zA-Z]</code> etc.</li>
<li>O símbolo <code>^</code> dentro do colchete significa negação. Por exemplo, <code>[^0-9]</code> significa pegar tudo o que não é número.</li>
<li>O símbolo <code>.</code> fora do colchete indica “qualquer caractere”, mas dentro do colchete é apenas ponto.</li>
<li>Use <code>[[:space:]]+</code> para reconhecer espaços e <code>[[:punct:]]+</code> para reconhecer pontuações.</li>
</ul>
</div>
<div id="miscelanea" class="section level2">
<h2>Miscelânea</h2>
<ul>
<li>Use <code>abjutils::rm_accent()</code> para retirar os acentos de um texto.</li>
<li>Use <code>|</code> para opções, por exemplo <code>desfavor|desprov</code> reconhece tanto “desfavorável” quanto “desprovido”</li>
<li><code>\n</code> pula linha, <code>\f</code> é final da página, <code>\t</code> é tab. Use <code>\</code> para transformar caracteres especiais em literais.</li>
<li><code>tolower()</code> e <code>toupper()</code> para mudar o case de uma string.</li>
</ul>
<p>A lista de possibilidades com expressões regulares é extensa. Um bom lugar para testar o funcionamento de expressões regulares é o <a href="https://regex101.com/">regex101</a>. #stringr: Avançado</p>
<p>Agora que já vimos as funções básicas do <code>stringr</code>, e aprendemos um pouco de regex, vamos às funções mais avançadas. Basicmante, essas funções buscarão <code>patterns</code> em um vetor de strings e farão alguma coisa quando encontrá-lo.</p>
<p>Como já vimos na sessão sobre regex, a função mais simples que possui o argumento <code>pattern</code> é a <code>str_detect</code>.</p>
<div id="str_detect" class="section level3">
<h3>str_detect()`</h3>
<p>Retorna <code>TRUE</code> se a regex é compatível com a string e <code>FALSE</code> caso contrário.</p>
<pre class="r"><code>library(stringr)
str_detect(&quot;sao paulo&quot;, pattern = &quot;paulo$&quot;)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>str_detect(&quot;sao paulo sp&quot;, pattern = &quot;paulo$&quot;)</code></pre>
<pre><code>## [1] FALSE</code></pre>
</div>
<div id="str_replace-e-str_replace_all" class="section level3">
<h3>str_replace() e str_replace_all()</h3>
<p>Substituem um padrão (ou todos) encontrado para um outro padrão</p>
<pre class="r"><code>frutas &lt;- c(&quot;uma maçã&quot;, &quot;duas pêras&quot;, &quot;três bananas&quot;)
str_replace(frutas, &quot;[aeiou]&quot;, &quot;-&quot;) # substitui a primeira vogal de cada string por &quot;-&quot;</code></pre>
<pre><code>## [1] &quot;-ma maçã&quot;     &quot;d-as pêras&quot;   &quot;três b-nanas&quot;</code></pre>
<pre class="r"><code>str_replace_all(frutas, &quot;[aeiou]&quot;, &quot;-&quot;) # substitui todas as vogais por &quot;-&quot;</code></pre>
<pre><code>## [1] &quot;-m- m-çã&quot;     &quot;d--s pêr-s&quot;   &quot;três b-n-n-s&quot;</code></pre>
<pre class="r"><code>yyyy &lt;- &quot;yyyyy yyyyy ll zz&quot;
str_replace(yyyy, &#39;y+&#39;, &#39;x&#39;) # substitui o primeiro 1 ou mais y&#39;s por x</code></pre>
<pre><code>## [1] &quot;x yyyyy ll zz&quot;</code></pre>
<pre class="r"><code>str_replace_all(yyyy, &#39;y+&#39;, &#39;x&#39;) # substitui todos os 1 ou mais y por somente 1 x</code></pre>
<pre><code>## [1] &quot;x x ll zz&quot;</code></pre>
<pre class="r"><code>str_replace_all(yyyy, &#39;y&#39;, &#39;x&#39;) # substitui y por x</code></pre>
<pre><code>## [1] &quot;xxxxx xxxxx ll zz&quot;</code></pre>
<pre class="r"><code>str_replace_all(&#39;string     com    muitos espaços&#39;, &#39; +&#39;, &#39; &#39;) # tirar espaços extras</code></pre>
<pre><code>## [1] &quot;string com muitos espaços&quot;</code></pre>
<p>Muitas vezes queremos remover alguns caracteres especiais de um texto, mas esses caracteres fazem parte de comandos de regex, por exemplo:</p>
<pre class="r"><code>string &lt;- &quot;1 + 2 + 5&quot;
#str_replace_all(string, &quot;+&quot;, &quot;-&quot;)</code></pre>
<p>Essa forma retorna um erro, pois a função tenta montar uma regex. Você poderia tentar de outras formas, que não retornariam erro, mas também não retornariam o resultado esperado.</p>
<pre class="r"><code>str_replace_all(string, &quot; + &quot;, &quot; - &quot;)</code></pre>
<pre><code>## [1] &quot;1 + 2 + 5&quot;</code></pre>
<p>Nesse caso, use a função <code>fixed</code> para indicar para o <code>stringr</code> que você não deseja que o parâmetro seja reconhecido como uma regex.</p>
<pre class="r"><code>str_replace_all(string, fixed(&quot;+&quot;), &quot;-&quot;)</code></pre>
<pre><code>## [1] &quot;1 - 2 - 5&quot;</code></pre>
</div>
<div id="str_match-e-str_match_all" class="section level3">
<h3>str_match() e str_match_all()</h3>
<p>Extrai pedaços da string identificados pela regex. Caso queira extrair somente a parte identificada, use parênteses.</p>
<pre class="r"><code>frases &lt;- c(&#39;a roupa do rei&#39;, &#39;de roma&#39;, &#39;o rato roeu&#39;)
str_match(frases, &#39;roe&#39;)</code></pre>
<pre><code>##      [,1] 
## [1,] NA   
## [2,] NA   
## [3,] &quot;roe&quot;</code></pre>
<pre class="r"><code>str_match_all(frases, &#39;ro&#39;)</code></pre>
<pre><code>## [[1]]
##      [,1]
## [1,] &quot;ro&quot;
## 
## [[2]]
##      [,1]
## [1,] &quot;ro&quot;
## 
## [[3]]
##      [,1]
## [1,] &quot;ro&quot;</code></pre>
<pre class="r"><code>str_match(frases, &#39;o (ro)&#39;)</code></pre>
<pre><code>##      [,1]   [,2]
## [1,] NA     NA  
## [2,] NA     NA  
## [3,] &quot;o ro&quot; &quot;ro&quot;</code></pre>
</div>
<div id="str_split-e-str_split_fixed" class="section level3">
<h3>str_split() e str_split_fixed()</h3>
<p>Separa uma string em várias de acordo com um separador.</p>
<pre class="r"><code>string &lt;- &#39;eu sei, usar virgulas, de forma, perfeita&#39;

str_split(string, &#39;, &#39;)</code></pre>
<pre><code>## [[1]]
## [1] &quot;eu sei&quot;        &quot;usar virgulas&quot; &quot;de forma&quot;      &quot;perfeita&quot;</code></pre>
<pre class="r"><code>str_split(string, &#39;, &#39;, simplify = TRUE)</code></pre>
<pre><code>##      [,1]     [,2]            [,3]       [,4]      
## [1,] &quot;eu sei&quot; &quot;usar virgulas&quot; &quot;de forma&quot; &quot;perfeita&quot;</code></pre>
<p>Faz o mesmo que <code>str_split()</code>, mas separa apenas <code>n</code> vezes</p>
<pre class="r"><code>str_split_fixed(string, &#39;, &#39;, 3)</code></pre>
<pre><code>##      [,1]     [,2]            [,3]                
## [1,] &quot;eu sei&quot; &quot;usar virgulas&quot; &quot;de forma, perfeita&quot;</code></pre>
<pre class="r"><code>str_split_fixed(string, &#39;, &#39;, 4) # igual a str_split(string, simplify = TRUE)</code></pre>
<pre><code>##      [,1]     [,2]            [,3]       [,4]      
## [1,] &quot;eu sei&quot; &quot;usar virgulas&quot; &quot;de forma&quot; &quot;perfeita&quot;</code></pre>
</div>
<div id="str_subset" class="section level3">
<h3>str_subset()</h3>
<p>Retorna somente as strings compatíveis com a regex.</p>
<pre class="r"><code>frases &lt;- c(&#39;a roupa do rei&#39;, &#39;de roma&#39;, &#39;o rato roeu&#39;)
str_subset(frases, &#39;d[eo]&#39;)</code></pre>
<pre><code>## [1] &quot;a roupa do rei&quot; &quot;de roma&quot;</code></pre>
<p>É o mesmo que fazer o subset do R e a função <code>str_detect</code>.</p>
<pre class="r"><code>frases[str_detect(frases, &quot;d[eo]&quot;)]</code></pre>
<pre><code>## [1] &quot;a roupa do rei&quot; &quot;de roma&quot;</code></pre>
</div>
</div>
</div>
<div id="untitled" class="section level1">
<h1>Untitled</h1>
<div id="exercicios" class="section level3">
<h3>Exercícios</h3>
<ol style="list-style-type: decimal">
<li>Considere o seguinte texto</li>
</ol>
<pre class="r"><code>txt &lt;- &quot;A função mais importante para leitura de dados no `lubridate` é a `ymd`. Essa função serve para ler qualquer data de uma `string` no formato `YYYY-MM-DD`. Essa função é útil pois funciona com qualquer separador entre os elementos da data e também porque temos uma função para cada formato (`mdy`, `dmy`, `dym`, `myd`, `ydm`).&quot;</code></pre>
<p>Extraia todas as combinações da função <code>ymd</code>, sem repetições.</p>
<ol start="2" style="list-style-type: decimal">
<li>Considere os textos abaixo</li>
</ol>
<pre class="r"><code>txts &lt;- c(
  &#39;o produto é muito bom&#39;,
  &#39;o produto não é bom&#39;,
  &#39;o produto não é muito bom&#39;,
  &#39;o produto não é ruim&#39;,
  &#39;o produto não é não bom&#39;
)</code></pre>
<p>Crie uma regra para identificar se o texto refere-se a um feedback positivo ou negativo sobre o produto (considera não bom = ruim e vice-versa). Retorne um vetor lógico que vale <code>TRUE</code> se o feedback é positivo e <code>FALSE</code> caso contrário. #‘index’ ##### str_to_upper, str_to_lower, str_to_title ##str_to_title(s) #### str_to_upper, str_to_lower, str_to_title #str_to_title(s) ##Untitled #Introdução: Stringr</p>
<p>Variáveis do tipo texto são muito comuns nos bancos de dados e geralmente são colunas que dão bastante trabalho para serem manipuladas. É muito comun encontrar bancos de dados em que os textos de uma coluna não estão padronizados, por exemplo uma coluna <code>Estado</code> em que são encontrados “SP”, “sp”, “Sao Paulo”, “São Paulo”, etc todas as variações indicando o mesmo estado.</p>
<p>Para manipular esses textos o R possui diversas funções para manipular textos, no entanto, as funções do <code>base</code> não possuem um interface consistente e parece que cada uma tem a sua forma de passar os parâmetros, dificultando o processo durante a análise.</p>
<p>Por isso, é recomendado usar o pacote <code>stringr</code> que possui a sintaxe consistente permitindo que o usuário realize qualquer manipulação com textos com maior facilidade.</p>
</div>
<div id="vantagens-do-stringr-em-relacao-ao-base-1" class="section level2">
<h2>Vantagens do stringr em relação ao base</h2>
<ul>
<li>Sintaxe unificada, o que auxilia na memorização e leitura do código.</li>
<li>Todas as funções são vetorizadas.</li>
<li>Construído sobre a <a href="http://site.icu-project.org/">biblioteca ICU</a>, implementada em <code>C</code> e <code>C++</code>, apresentando resultados rápidos e confiáveis.</li>
</ul>
</div>
<div id="regras-basicas-do-pacote-1" class="section level2">
<h2>Regras básicas do pacote</h2>
<ul>
<li>As funções de manipulação de texto começam com <code>str_</code>. Caso esqueça o nome de uma função, basta digitar <code>stringr::str_</code> e apertar <code>TAB</code> para ver quais são as opções.</li>
<li>O primeiro argumento da função é sempre uma <code>string</code> ou um vetor de <code>strings</code>.</li>
</ul>
</div>
<div id="curiosidade-1" class="section level2">
<h2>Curiosidade</h2>
<p>Inicialmente, o <code>stringr</code> era um <em>wrapper</em> de funções do <code>base</code>. Depois disso, surgiu um novo pacote <code>stringi</code>, com sintaxe similar ao <code>stringr</code>, mas funcionando como <em>wrapper</em> da biblioteca ICU. No entanto, Wickham gostou tanto do pacote <code>stringi</code> que decidiu reescrever o <code>stringr</code> como um <em>wrapper</em> do <code>stringi</code>. Veja <a href="https://github.com/tidyverse/stringr/blob/master/NEWS.md">essa página</a> para detalhes. #stringr: Básico #### str_to_upper, str_to_lower, str_to_title #str_to_title(s)</p>
<p>Todas as funções do <code>stringr</code> começam com o prefixo <code>str</code>, isso ajuda na hora de encontrar a função que você está procurando. No Rstudio, basta digitar <code>str_</code> e apertar tab que você verá algo parecido com a imagem a baixo. Você pode ir descendo com as setas do teclado e ver o que cada função faz até encontrar a função que estava procurando.</p>
<div class="figure">
<img src="../home/travis/build/azeloc/pu.test/figure/str_tab.png" alt="str_tab" />
<p class="caption">str_tab</p>
</div>
<p>Nesta sessão vamos utilizar as funções mais simples do <code>stringr</code>, depois vamos ensinar um pouco de Regex e em seguida veremos as funções mais avançadas do pacote.</p>
</div>
<div id="funcoes-basicas-1" class="section level2">
<h2>Funções básicas</h2>
<div id="str_length-1" class="section level3">
<h3>str_length</h3>
<p>A função mais simples do <code>stringr</code> é a função <code>str_length</code>. Esta função recebe apenas uma string como argumento e retorna o número de caracteres. Por exemplo:</p>
<pre class="r"><code>library(stringr)
str_length(&quot;olá&quot;)</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code>length(&quot;olá&quot;)</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Veja <code>str_length</code> é diferente de <code>length</code>. O primeiro retorna o número de caracteres e o segundo retorna o comprimento do objeto. Isso fica mais claro no seguinte exemplo:</p>
<pre class="r"><code>s &lt;- c(&quot;olá mundo&quot;, &quot;olá universo&quot;)
str_length(s)</code></pre>
<pre><code>## [1]  9 12</code></pre>
<pre class="r"><code>length(s)</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Agora o <code>str_length</code> retornou um vetor com o número de caracteres de cada elemento do vetor <code>s</code>, e o <code>length</code> retornou o comprimento do vetor <code>s</code>. Note que espaço é considerado como um caractere.</p>
</div>
<div id="str_trim-1" class="section level3">
<h3>str_trim</h3>
<p>É muito comum encontrar textos que vêm com espaços a mais, principalmente de dados provenientes de formulários em que cada usuário escreve da forma que prefere.</p>
<pre class="r"><code>string &lt;- &#39;\nessa      string é muito suja       \n&#39;
str_trim(string)</code></pre>
<pre><code>## [1] &quot;essa      string é muito suja&quot;</code></pre>
<p>A função <code>str_trim</code> ajuda removendo os espaços excedetes antes e depois da string.</p>
</div>
<div id="str_sub-1" class="section level3">
<h3>str_sub</h3>
<p>As vezes você precisa obter alguma parte fixa de uma string. Por exemplo, as vezes você encontra variáveis com valores da forma:</p>
<pre class="r"><code>s &lt;- c(&quot;01-Feminino&quot;, &quot;02-Masculino&quot;, &quot;03-Indefinido&quot;)</code></pre>
<p>Você pode querer manipular essa string para retirar obter apenas a parte final da string. Neste caso pode usar a função <code>str_sub</code></p>
<pre class="r"><code>str_sub(s, start = 4) # pegar do quarto até o último caractere</code></pre>
<pre><code>## [1] &quot;Feminino&quot;   &quot;Masculino&quot;  &quot;Indefinido&quot;</code></pre>
<p>É possível obter também apenas os números</p>
<pre class="r"><code>str_sub(s, end = 2) # pegar apenas os dois primeiros caracteres</code></pre>
<pre><code>## [1] &quot;01&quot; &quot;02&quot; &quot;03&quot;</code></pre>
<p>Em outros casos você precisa obter os últimos 2 caracteres.</p>
<pre class="r"><code>s &lt;- c(&quot;Feminino-01&quot;, &quot;Masculino-02&quot;, &quot;Indefinido-03&quot;)
str_sub(s, end = -4)</code></pre>
<pre><code>## [1] &quot;Feminino&quot;   &quot;Masculino&quot;  &quot;Indefinido&quot;</code></pre>
<pre class="r"><code>str_sub(s, start = -2)</code></pre>
<pre><code>## [1] &quot;01&quot; &quot;02&quot; &quot;03&quot;</code></pre>
<p>É possível também usar os argumentos <code>start</code> e <code>end</code> conjuntamente.</p>
<pre class="r"><code>s &lt;- c(&quot;__SP__&quot;, &quot;__MG__&quot;, &quot;__RJ__&quot;)
str_sub(s, 3, 4)</code></pre>
<pre><code>## [1] &quot;SP&quot; &quot;MG&quot; &quot;RJ&quot;</code></pre>
</div>
<div id="str_to_upper-str_to_lower-str_to_title-1" class="section level3">
<h3>str_to_upper, str_to_lower, str_to_title</h3>
<p>Essas funções servem para modificar a caixa das letras. Por exemplo:</p>
<pre class="r"><code>s &lt;- &quot;Olá, tudo bem?&quot;
str_to_lower(s)</code></pre>
<pre><code>## [1] &quot;olá, tudo bem?&quot;</code></pre>
<pre class="r"><code>str_to_upper(s)</code></pre>
<pre><code>## [1] &quot;OLÁ, TUDO BEM?&quot;</code></pre>
<pre class="r"><code>str_to_title(s)</code></pre>
<pre><code>## [1] &quot;Olá, Tudo Bem?&quot;</code></pre>
<p>Essas são as funções mais simples do pacote <code>stringr</code> e mão exigem nenhum conhecimento de regex. Note que nenhuma delas possui o parâmetro <code>pattern</code>, você verá como especificar esse parâmetros nas próximas sessões.</p>
</div>
</div>
</div>
<div id="regex-1" class="section level1">
<h1>Regex</h1>
<p>Trabalhar com textos exige um certo conhecimento de expressões regulares (<em>regex</em>). <a href="https://pt.wikipedia.org/wiki/Express%C3%A3o_regular">Expressões regulares</a> permitem identificar conjuntos de caracters, palavras, e outros padrões por meio de uma sintaxe concisa.</p>
<p>O <code>stringr</code> utiliza regex da forma descrita <a href="http://www.gagolewski.com/software/stringi/manual/?manpage=stringi-search-regex">neste documento</a>. A própria <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html">definição</a> de regex do R é um ótimo manual.</p>
<div id="expressoes-regulares-1" class="section level2">
<h2>Expressões regulares</h2>
<p>Expressão regular ou <em>regex</em> é uma sequência concisa de caracteres que representa várias strings. Entender o básico de expressões regulares é indispensável para trabalhar com textos.</p>
<p>Vamos estudar expressões regulares através de exemplos e com a função <code>str_detect()</code>. Essa função retorna <code>TRUE</code> se uma string atende à uma expressão regular e <code>FALSE</code> em caso contrário.</p>
<p>Por exemplo:</p>
<pre class="r"><code>library(stringr)
str_detect(&quot;sao paulo&quot;, pattern = &quot;paulo$&quot;)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>str_detect(&quot;sao paulo sp&quot;, pattern = &quot;paulo$&quot;)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>A regex/pattern “paulo<span class="math inline">\(&quot; indica que o texto deve ser terminado em &quot;paulo&quot;. Existem diversos de caracteres auxiliares que vão auxiliar na manipulação dos textos, assim como o &quot;\)</span>” neste caso. É importante notar que sempre que você estiver passando algum valor para o argumento <code>pattern</code> de qualquer função do <code>stringr</code> ele o entenderá como uma regex.</p>
<p>A tabela abaixo mostra a aplicação de seis <code>regex</code> a seis strings distintas.</p>
<pre class="r"><code>testes &lt;- c(&#39;ban&#39;, &#39;banana&#39;, &#39;abandonado&#39;, &#39;pranab anderson&#39;, &#39;BANANA&#39;, 
            &#39;ele levou ban&#39;)

expressoes &lt;- list(
  &#39;ban&#39;, # reconhece tudo que tenha &quot;ban&quot;, mas não ignora case
  &#39;BAN&#39;, # reconhece tudo que tenha &quot;BAN&quot;, mas não ignora case
  regex(&#39;ban&#39;, ignore_case = TRUE), # reconhece tudo que tenha &quot;ban&quot;, ignorando case
  &#39;ban$&#39;, # reconhece apenas o que termina exatamente em &quot;ban&quot;
  &#39;^ban&#39;, # reconhece apenas o que começa exatamente com &quot;ban&quot;
  &#39;b ?an&#39; # reconhece tudo que tenha &quot;ban&quot;, com ou sem espaço entre o &quot;b&quot; e o &quot;a&quot;
)</code></pre>
</div>
<div id="quantificadores-1" class="section level2">
<h2>Quantificadores</h2>
<p>Os caracteres <code>+</code>, <code>*</code> e <code>{x,y}</code> indicam quantas vezes um padrão se repete:</p>
<ul>
<li><code>ey+</code> significa <code>e</code> e depois <code>y</code> “<strong>uma vez</strong> ou mais”. Por exemplo, reconhece <code>hey</code>, <code>heyy</code>, <code>a eyyy</code>, mas não reconhece <code>e</code>, <code>y</code> nem <code>yy</code>.</li>
<li><code>ey*</code> significa “<strong>zero vezes</strong> ou mais”. Por exemplo, reconhece <code>hey</code>, <code>heyy</code>, <code>a eyyy</code> e <code>e</code>, mas não reconhece <code>y</code> nem <code>yy</code>.</li>
<li><code>ey{3}</code> significa “exatamente três vezes”. Por exemplo, reconhece <code>eyyy</code> e <code>eyyyy</code>, mas não reconhece <code>eyy</code>.</li>
<li><code>ey{1,3}</code> significa “entre uma e três vezes”.</li>
</ul>
<p>Para aplicar um quantificador a um conjunto de caracteres, use parênteses. Por exemplo, <code>(ey )+</code> reconhece <code>ey ey</code>.</p>
</div>
<div id="conjuntos-1" class="section level2">
<h2>Conjuntos</h2>
<p>Colocando caracteres dentro de <code>[]</code>, reconhecemos quaisquer caracteres desse conjunto. Alguns exemplos práticos:</p>
<ul>
<li><code>[Cc]asa</code> para reconhecer “casa” em maiúsculo ou minúsculo.</li>
<li><code>[0-9]</code> para reconhecer somente números. O mesmo vale para letras <code>[a-z]</code>, <code>[A-Z]</code>, <code>[a-zA-Z]</code> etc.</li>
<li>O símbolo <code>^</code> dentro do colchete significa negação. Por exemplo, <code>[^0-9]</code> significa pegar tudo o que não é número.</li>
<li>O símbolo <code>.</code> fora do colchete indica “qualquer caractere”, mas dentro do colchete é apenas ponto.</li>
<li>Use <code>[[:space:]]+</code> para reconhecer espaços e <code>[[:punct:]]+</code> para reconhecer pontuações.</li>
</ul>
</div>
<div id="miscelanea-1" class="section level2">
<h2>Miscelânea</h2>
<ul>
<li>Use <code>abjutils::rm_accent()</code> para retirar os acentos de um texto.</li>
<li>Use <code>|</code> para opções, por exemplo <code>desfavor|desprov</code> reconhece tanto “desfavorável” quanto “desprovido”</li>
<li><code>\n</code> pula linha, <code>\f</code> é final da página, <code>\t</code> é tab. Use <code>\</code> para transformar caracteres especiais em literais.</li>
<li><code>tolower()</code> e <code>toupper()</code> para mudar o case de uma string.</li>
</ul>
<p>A lista de possibilidades com expressões regulares é extensa. Um bom lugar para testar o funcionamento de expressões regulares é o <a href="https://regex101.com/">regex101</a>. #stringr: Avançado</p>
<p>Agora que já vimos as funções básicas do <code>stringr</code>, e aprendemos um pouco de regex, vamos às funções mais avançadas. Basicmante, essas funções buscarão <code>patterns</code> em um vetor de strings e farão alguma coisa quando encontrá-lo.</p>
<p>Como já vimos na sessão sobre regex, a função mais simples que possui o argumento <code>pattern</code> é a <code>str_detect</code>.</p>
<div id="str_detect-1" class="section level3">
<h3>str_detect()`</h3>
<p>Retorna <code>TRUE</code> se a regex é compatível com a string e <code>FALSE</code> caso contrário.</p>
<pre class="r"><code>library(stringr)
str_detect(&quot;sao paulo&quot;, pattern = &quot;paulo$&quot;)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>str_detect(&quot;sao paulo sp&quot;, pattern = &quot;paulo$&quot;)</code></pre>
<pre><code>## [1] FALSE</code></pre>
</div>
<div id="str_replace-e-str_replace_all-1" class="section level3">
<h3>str_replace() e str_replace_all()</h3>
<p>Substituem um padrão (ou todos) encontrado para um outro padrão</p>
<pre class="r"><code>frutas &lt;- c(&quot;uma maçã&quot;, &quot;duas pêras&quot;, &quot;três bananas&quot;)
str_replace(frutas, &quot;[aeiou]&quot;, &quot;-&quot;) # substitui a primeira vogal de cada string por &quot;-&quot;</code></pre>
<pre><code>## [1] &quot;-ma maçã&quot;     &quot;d-as pêras&quot;   &quot;três b-nanas&quot;</code></pre>
<pre class="r"><code>str_replace_all(frutas, &quot;[aeiou]&quot;, &quot;-&quot;) # substitui todas as vogais por &quot;-&quot;</code></pre>
<pre><code>## [1] &quot;-m- m-çã&quot;     &quot;d--s pêr-s&quot;   &quot;três b-n-n-s&quot;</code></pre>
<pre class="r"><code>yyyy &lt;- &quot;yyyyy yyyyy ll zz&quot;
str_replace(yyyy, &#39;y+&#39;, &#39;x&#39;) # substitui o primeiro 1 ou mais y&#39;s por x</code></pre>
<pre><code>## [1] &quot;x yyyyy ll zz&quot;</code></pre>
<pre class="r"><code>str_replace_all(yyyy, &#39;y+&#39;, &#39;x&#39;) # substitui todos os 1 ou mais y por somente 1 x</code></pre>
<pre><code>## [1] &quot;x x ll zz&quot;</code></pre>
<pre class="r"><code>str_replace_all(yyyy, &#39;y&#39;, &#39;x&#39;) # substitui y por x</code></pre>
<pre><code>## [1] &quot;xxxxx xxxxx ll zz&quot;</code></pre>
<pre class="r"><code>str_replace_all(&#39;string     com    muitos espaços&#39;, &#39; +&#39;, &#39; &#39;) # tirar espaços extras</code></pre>
<pre><code>## [1] &quot;string com muitos espaços&quot;</code></pre>
<p>Muitas vezes queremos remover alguns caracteres especiais de um texto, mas esses caracteres fazem parte de comandos de regex, por exemplo:</p>
<pre class="r"><code>string &lt;- &quot;1 + 2 + 5&quot;
#str_replace_all(string, &quot;+&quot;, &quot;-&quot;)</code></pre>
<p>Essa forma retorna um erro, pois a função tenta montar uma regex. Você poderia tentar de outras formas, que não retornariam erro, mas também não retornariam o resultado esperado.</p>
<pre class="r"><code>str_replace_all(string, &quot; + &quot;, &quot; - &quot;)</code></pre>
<pre><code>## [1] &quot;1 + 2 + 5&quot;</code></pre>
<p>Nesse caso, use a função <code>fixed</code> para indicar para o <code>stringr</code> que você não deseja que o parâmetro seja reconhecido como uma regex.</p>
<pre class="r"><code>str_replace_all(string, fixed(&quot;+&quot;), &quot;-&quot;)</code></pre>
<pre><code>## [1] &quot;1 - 2 - 5&quot;</code></pre>
</div>
<div id="str_match-e-str_match_all-1" class="section level3">
<h3>str_match() e str_match_all()</h3>
<p>Extrai pedaços da string identificados pela regex. Caso queira extrair somente a parte identificada, use parênteses.</p>
<pre class="r"><code>frases &lt;- c(&#39;a roupa do rei&#39;, &#39;de roma&#39;, &#39;o rato roeu&#39;)
str_match(frases, &#39;roe&#39;)</code></pre>
<pre><code>##      [,1] 
## [1,] NA   
## [2,] NA   
## [3,] &quot;roe&quot;</code></pre>
<pre class="r"><code>str_match_all(frases, &#39;ro&#39;)</code></pre>
<pre><code>## [[1]]
##      [,1]
## [1,] &quot;ro&quot;
## 
## [[2]]
##      [,1]
## [1,] &quot;ro&quot;
## 
## [[3]]
##      [,1]
## [1,] &quot;ro&quot;</code></pre>
<pre class="r"><code>str_match(frases, &#39;o (ro)&#39;)</code></pre>
<pre><code>##      [,1]   [,2]
## [1,] NA     NA  
## [2,] NA     NA  
## [3,] &quot;o ro&quot; &quot;ro&quot;</code></pre>
</div>
<div id="str_split-e-str_split_fixed-1" class="section level3">
<h3>str_split() e str_split_fixed()</h3>
<p>Separa uma string em várias de acordo com um separador.</p>
<pre class="r"><code>string &lt;- &#39;eu sei, usar virgulas, de forma, perfeita&#39;

str_split(string, &#39;, &#39;)</code></pre>
<pre><code>## [[1]]
## [1] &quot;eu sei&quot;        &quot;usar virgulas&quot; &quot;de forma&quot;      &quot;perfeita&quot;</code></pre>
<pre class="r"><code>str_split(string, &#39;, &#39;, simplify = TRUE)</code></pre>
<pre><code>##      [,1]     [,2]            [,3]       [,4]      
## [1,] &quot;eu sei&quot; &quot;usar virgulas&quot; &quot;de forma&quot; &quot;perfeita&quot;</code></pre>
<p>Faz o mesmo que <code>str_split()</code>, mas separa apenas <code>n</code> vezes</p>
<pre class="r"><code>str_split_fixed(string, &#39;, &#39;, 3)</code></pre>
<pre><code>##      [,1]     [,2]            [,3]                
## [1,] &quot;eu sei&quot; &quot;usar virgulas&quot; &quot;de forma, perfeita&quot;</code></pre>
<pre class="r"><code>str_split_fixed(string, &#39;, &#39;, 4) # igual a str_split(string, simplify = TRUE)</code></pre>
<pre><code>##      [,1]     [,2]            [,3]       [,4]      
## [1,] &quot;eu sei&quot; &quot;usar virgulas&quot; &quot;de forma&quot; &quot;perfeita&quot;</code></pre>
</div>
<div id="str_subset-1" class="section level3">
<h3>str_subset()</h3>
<p>Retorna somente as strings compatíveis com a regex.</p>
<pre class="r"><code>frases &lt;- c(&#39;a roupa do rei&#39;, &#39;de roma&#39;, &#39;o rato roeu&#39;)
str_subset(frases, &#39;d[eo]&#39;)</code></pre>
<pre><code>## [1] &quot;a roupa do rei&quot; &quot;de roma&quot;</code></pre>
<p>É o mesmo que fazer o subset do R e a função <code>str_detect</code>.</p>
<pre class="r"><code>frases[str_detect(frases, &quot;d[eo]&quot;)]</code></pre>
<pre><code>## [1] &quot;a roupa do rei&quot; &quot;de roma&quot;</code></pre>
</div>
</div>
</div>
<div id="untitled-1" class="section level1">
<h1>Untitled</h1>
<div id="exercicios-1" class="section level3">
<h3>Exercícios</h3>
<ol style="list-style-type: decimal">
<li>Considere o seguinte texto</li>
</ol>
<pre class="r"><code>txt &lt;- &quot;A função mais importante para leitura de dados no `lubridate` é a `ymd`. Essa função serve para ler qualquer data de uma `string` no formato `YYYY-MM-DD`. Essa função é útil pois funciona com qualquer separador entre os elementos da data e também porque temos uma função para cada formato (`mdy`, `dmy`, `dym`, `myd`, `ydm`).&quot;</code></pre>
<p>Extraia todas as combinações da função <code>ymd</code>, sem repetições.</p>
<ol start="2" style="list-style-type: decimal">
<li>Considere os textos abaixo</li>
</ol>
<pre class="r"><code>txts &lt;- c(
  &#39;o produto é muito bom&#39;,
  &#39;o produto não é bom&#39;,
  &#39;o produto não é muito bom&#39;,
  &#39;o produto não é ruim&#39;,
  &#39;o produto não é não bom&#39;
)</code></pre>
<p>Crie uma regra para identificar se o texto refere-se a um feedback positivo ou negativo sobre o produto (considera não bom = ruim e vice-versa). Retorne um vetor lógico que vale <code>TRUE</code> se o feedback é positivo e <code>FALSE</code> caso contrário.</p>
</div>
</div>


<!-- BLOGDOWN-HEAD

<script src="index_files/htmlwidgets-0.8/htmlwidgets.js"></script>
<script src="index_files/jquery-1.12.4/jquery.min.js"></script>
<script src="index_files/datatables-binding-0.2/datatables.js"></script>
<link href="index_files/dt-core-1.10.12/css/jquery.dataTables.min.css" rel="stylesheet" />
<link href="index_files/dt-core-1.10.12/css/jquery.dataTables.extra.css" rel="stylesheet" />
<script src="index_files/dt-core-1.10.12/js/jquery.dataTables.min.js"></script>



/BLOGDOWN-HEAD -->


			<aside class="copyright" role="note">
				
				&copy; 2017 Disponível sobre Licença MIT &ndash;
				
				Site built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				

<nav class="pagination" aria-label="Footer">
  <div class="previous">
  
      <a href="../manip/" title="">
        <span class="direction">
          Previous
        </span>
        <div class="page">
          <div class="button button-previous" role="button" aria-label="Previous">
            <i class="icon icon-back"></i>
          </div>
          <div class="stretch">
            <div class="title">
              
            </div>
          </div>
        </div>
      </a>
  
  </div>

  <div class="next">
  
      <a href="../rbase/" title="Introdução">
        <span class="direction">
          Next
        </span>
        <div class="page">
          <div class="stretch">
            <div class="title">
              Introdução
            </div>
          </div>
          <div class="button button-next" role="button" aria-label="Next">
            <i class="icon icon-forward"></i>
          </div>
        </div>
      </a>
  
  </div>
</nav>





			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = '\/';
      var repo_id  = 'curso-r\/verao2017';
    
    </script>
    
    <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="../javascripts/application.js"></script>
    <script src="../javascripts/datacamp.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var div_h2    = document.getElementsByClassName("section level2")
      var headers   = document.getElementsByTagName("h2");	
      var scrollspy = document.getElementById('scrollspy');
      
      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");


	    if(headers[i].id == ""){
	     a.setAttribute("href", "#" + div_h2[i].id);
	    } else {
	     a.setAttribute("href", "#" + headers[i].id);
	    }

            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;
            
            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }
      }
      
      
      /* Add permanent link next to the headers */
      var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

      for(var i = 0; i < headers.length; i++) {
          var a = document.createElement("a");
          a.setAttribute("class", "headerlink");
          a.setAttribute("href", "#" + headers[i].id);
          a.setAttribute("title", "Permanent link")
          a.innerHTML = "#";
          headers[i].appendChild(a);
      }
    </script>

    
      <script>
        (function(i,s,o,g,r,a,m){
          i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||
          []).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;
          m.parentNode.insertBefore(a,m)
        })(window, document,
          'script', '//www.google-analytics.com/analytics.js', 'ga');
         
        ga('create', 'UA-87272102-1', 'auto');
        ga('set', 'anonymizeIp', true);
        ga('send', 'pageview');
         
        var buttons = document.querySelectorAll('a');
        Array.prototype.map.call(buttons, function(item) {
          if (item.host != document.location.host) {
            item.addEventListener('click', function() {
              var action = item.getAttribute('data-action') || 'follow';
              ga('send', 'event', 'outbound', action, item.href);
            });
          }
        });
         
        var query = document.querySelector('.query');
        query.addEventListener('blur', function() {
          if (this.value) {
            var path = document.location.pathname;
            ga('send', 'pageview', path + '?q=' + this.value);
          }
        });
      </script>
    

    <script src="//gohugo.io/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

