<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Curso-R</title>
    <link>/index.xml</link>
    <description>Recent content on Curso-R</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <copyright>Disponível sobre Licença MIT</copyright>
    <lastBuildDate>Tue, 24 Jan 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Introdução</title>
      <link>/manip/</link>
      <pubDate>Tue, 24 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/manip/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&amp;rdquo;(&amp;hellip;) The fact that data science exists as a field is a colossal failure of statistics. To me, what I do is what statistics is all about. It is gaining insight from data using modelling and visualization. Data munging and manipulation is hard and statistics has just said that’s not our domain.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Hadley Wickham&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://r4ds.had.co.nz/diagrams/data-science-wrangle.png&#34; alt=&#34;transform&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;pacotes-dplyr-e-tidyr&#34;&gt;Pacotes &lt;code&gt;dplyr&lt;/code&gt; e &lt;code&gt;tidyr&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;A transformação de dados é uma tarefa dolorosa e demorada, tomando muitas vezes a maior parte do tempo de uma análise estatística.&lt;/p&gt;

&lt;p&gt;O &lt;code&gt;dplyr&lt;/code&gt; é o pacote mais útil para realizar transformação de dados, aliando simplicidade e eficiência de uma forma elegante. Os scripts em &lt;code&gt;R&lt;/code&gt; que fazem uso inteligente dos verbos &lt;code&gt;dplyr&lt;/code&gt; e as facilidades do operador &lt;em&gt;pipe&lt;/em&gt; tendem a ficar mais legíveis e organizados, sem perder velocidade de execução.&lt;/p&gt;

&lt;p&gt;O &lt;code&gt;dplyr&lt;/code&gt; pode ser considerado como uma revolução no &lt;code&gt;R&lt;/code&gt;, por auxiliar num dos trabalhos mais árduos da análise estatística, atingindo esse objetivo de forma elegante, eficaz e eficiente.&lt;/p&gt;

&lt;h3 id=&#34;trabalhando-com-tibble-s&#34;&gt;Trabalhando com &lt;code&gt;tibble&lt;/code&gt;s&lt;/h3&gt;

&lt;p&gt;Uma &lt;code&gt;tibble&lt;/code&gt; nada mais é do que um &lt;code&gt;data.frame&lt;/code&gt;, mas com um método de impressão mais adequado. Outras diferenças podem ser estudadas &lt;a href=&#34;http://r4ds.had.co.nz/tibbles.html&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Considere a seguinte base de dados.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min
## # A tibble: 16,686 × 14
##      ano                  muni    uf regiao  idhm idhm_e idhm_l idhm_r
##    &amp;lt;int&amp;gt;                 &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1   1991 ALTA FLORESTA D&#39;OESTE    RO  Norte 0.329  0.112  0.617  0.516
## 2   1991             ARIQUEMES    RO  Norte 0.432  0.199  0.684  0.593
## 3   1991                CABIXI    RO  Norte 0.309  0.108  0.636  0.430
## 4   1991                CACOAL    RO  Norte 0.407  0.171  0.667  0.593
## 5   1991            CEREJEIRAS    RO  Norte 0.386  0.167  0.629  0.547
## 6   1991     COLORADO DO OESTE    RO  Norte 0.376  0.151  0.658  0.536
## 7   1991            CORUMBIARA    RO  Norte 0.203  0.039  0.572  0.373
## 8   1991         COSTA MARQUES    RO  Norte 0.425  0.220  0.629  0.553
## 9   1991       ESPIGÃO D&#39;OESTE    RO  Norte 0.388  0.159  0.653  0.561
## 10  1991         GUAJARÁ-MIRIM    RO  Norte 0.468  0.247  0.662  0.625
## # ... with 16,676 more rows, and 6 more variables: espvida &amp;lt;dbl&amp;gt;,
## #   rdpc &amp;lt;dbl&amp;gt;, gini &amp;lt;dbl&amp;gt;, pop &amp;lt;int&amp;gt;, lat &amp;lt;dbl&amp;gt;, lon &amp;lt;dbl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;base-idh-municipal-pnud&#34;&gt;Base IDH-Municipal - PNUD&lt;/h2&gt;

&lt;p&gt;Nessa seção vamos trabalhar com uma base simplificada do &lt;a href=&#34;http://www.atlasbrasil.org.br/2013/pt/download/base/&#34;&gt;PNUD (Programa das Nações Unidas para o Desenvolvimento)&lt;/a&gt;, contendo informações socioeconômicas de todos os municípios do país. Os resultados foram obtidos a partir dos Censos de 1991, 2000 e 2010.&lt;/p&gt;

&lt;p&gt;A base contém 16686 linhas e 14 colunas, descritas abaixo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ano&lt;/code&gt; ano do Censo utilizado como base para cálculo do IDH-Municipal e outras métricas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;muni&lt;/code&gt; nome do município. Cada município aparece três vezes, um para cada ano.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uf&lt;/code&gt; Unidade Federativa.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;regiao&lt;/code&gt; região brasileira.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idhm&lt;/code&gt; IDH municipal, dividido em

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;idhm_e&lt;/code&gt; IDH municipal - educação.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idhm_l&lt;/code&gt; IDH municipal - longevidade.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idhm_r&lt;/code&gt; IDH municipal - renda.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;espvida&lt;/code&gt; expectativa de vida.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rdpc&lt;/code&gt; renda &lt;em&gt;per capita&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gini&lt;/code&gt; coeficiente de gini municipal (mede desigualdade social).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop&lt;/code&gt; população residente do município.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lat&lt;/code&gt;, &lt;code&gt;lon&lt;/code&gt; latitude e longitude do município (ponto médio).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;os-cinco-verbos-do-dplyr&#34;&gt;Os cinco verbos do &lt;code&gt;dplyr&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;filter&lt;/code&gt;: filtrar linhas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select&lt;/code&gt;: selecionar colunas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mutate&lt;/code&gt;: criar/modificar colunas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arrange&lt;/code&gt;: ordenar a base.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;summarise&lt;/code&gt;: sumarizar a base em uma linha.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;características&#34;&gt;Características&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;O &lt;em&gt;input&lt;/em&gt;  é sempre uma &lt;code&gt;tibble&lt;/code&gt;, e o &lt;em&gt;output&lt;/em&gt;  é sempre um &lt;code&gt;tibble&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;No primeiro argumento colocamos o &lt;code&gt;tibble&lt;/code&gt;, e nos outros argumentos colocamos o que queremos fazer.&lt;/li&gt;
&lt;li&gt;A utilização é facilitada com o emprego do operador &lt;code&gt;%&amp;gt;%&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;O pacote faz uso extensivo de NSE (&lt;em&gt;non standard evaluation&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;vantagens&#34;&gt;Vantagens&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Utiliza &lt;code&gt;C&lt;/code&gt; e &lt;code&gt;C++&lt;/code&gt; por trás da maioria das funções, o que geralmente torna o código mais eficiente.&lt;/li&gt;
&lt;li&gt;Pode trabalhar com diferentes fontes de dados, como bases relacionais (SQL) e &lt;code&gt;data.table&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;select&#34;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Utilizar &lt;code&gt;starts_with(x)&lt;/code&gt;, &lt;code&gt;contains(x)&lt;/code&gt;, &lt;code&gt;matches(x)&lt;/code&gt;, &lt;code&gt;one_of(x)&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;Possível colocar nomes, índices, e intervalos de variáveis com &lt;code&gt;:&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(ano, regiao, muni)
## # A tibble: 16,686 × 3
##      ano regiao                  muni
##    &amp;lt;int&amp;gt;  &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;
## 1   1991  Norte ALTA FLORESTA D&#39;OESTE
## 2   1991  Norte             ARIQUEMES
## 3   1991  Norte                CABIXI
## 4   1991  Norte                CACOAL
## 5   1991  Norte            CEREJEIRAS
## 6   1991  Norte     COLORADO DO OESTE
## 7   1991  Norte            CORUMBIARA
## 8   1991  Norte         COSTA MARQUES
## 9   1991  Norte       ESPIGÃO D&#39;OESTE
## 10  1991  Norte         GUAJARÁ-MIRIM
## # ... with 16,676 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(ano:regiao, rdpc)
## # A tibble: 16,686 × 5
##      ano                  muni    uf regiao   rdpc
##    &amp;lt;int&amp;gt;                 &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt;
## 1   1991 ALTA FLORESTA D&#39;OESTE    RO  Norte 198.46
## 2   1991             ARIQUEMES    RO  Norte 319.47
## 3   1991                CABIXI    RO  Norte 116.38
## 4   1991                CACOAL    RO  Norte 320.24
## 5   1991            CEREJEIRAS    RO  Norte 240.10
## 6   1991     COLORADO DO OESTE    RO  Norte 224.82
## 7   1991            CORUMBIARA    RO  Norte  81.38
## 8   1991         COSTA MARQUES    RO  Norte 250.08
## 9   1991       ESPIGÃO D&#39;OESTE    RO  Norte 263.03
## 10  1991         GUAJARÁ-MIRIM    RO  Norte 391.37
## # ... with 16,676 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(ano, starts_with(&#39;idhm&#39;))
## # A tibble: 16,686 × 5
##      ano  idhm idhm_e idhm_l idhm_r
##    &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1   1991 0.329  0.112  0.617  0.516
## 2   1991 0.432  0.199  0.684  0.593
## 3   1991 0.309  0.108  0.636  0.430
## 4   1991 0.407  0.171  0.667  0.593
## 5   1991 0.386  0.167  0.629  0.547
## 6   1991 0.376  0.151  0.658  0.536
## 7   1991 0.203  0.039  0.572  0.373
## 8   1991 0.425  0.220  0.629  0.553
## 9   1991 0.388  0.159  0.653  0.561
## 10  1991 0.468  0.247  0.662  0.625
## # ... with 16,676 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;filter&#34;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Parecido com &lt;code&gt;subset&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Condições separadas por vírgulas é o mesmo que separar por &lt;code&gt;&amp;amp;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(ano, muni, uf) %&amp;gt;% 
  filter(uf == &#39;AC&#39;)
## # A tibble: 66 × 3
##      ano            muni    uf
##    &amp;lt;int&amp;gt;           &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
## 1   1991      ACRELÂNDIA    AC
## 2   1991    ASSIS BRASIL    AC
## 3   1991       BRASILÉIA    AC
## 4   1991          BUJARI    AC
## 5   1991        CAPIXABA    AC
## 6   1991 CRUZEIRO DO SUL    AC
## 7   1991  EPITACIOLÂNDIA    AC
## 8   1991           FEIJÓ    AC
## 9   1991          JORDÃO    AC
## 10  1991     MÂNCIO LIMA    AC
## # ... with 56 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para fazer várias condições, use os operadores lógicos (&lt;code&gt;&amp;amp;&lt;/code&gt; e &lt;code&gt;|&lt;/code&gt;) ou separando filtros entre vírgulas.&lt;/p&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
`%in%`
&lt;/p&gt;
&lt;p&gt;
`%in%` é um operador muito útil para trabalhar com vetores. O resultado da operação é um vetor lógico do tamanho do vetor do elemento da esquerda, identificando quais elementos da esquerda batem com algum elemento da direita.
&lt;/p&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(ano, regiao, uf, idhm) %&amp;gt;% 
  filter(uf %in% c(&#39;SP&#39;, &#39;MG&#39;) | idhm &amp;gt; .5, ano == 2010)
## # A tibble: 5,527 × 4
##      ano regiao    uf  idhm
##    &amp;lt;int&amp;gt;  &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1   2010  Norte    RO 0.641
## 2   2010  Norte    RO 0.702
## 3   2010  Norte    RO 0.650
## 4   2010  Norte    RO 0.718
## 5   2010  Norte    RO 0.692
## 6   2010  Norte    RO 0.685
## 7   2010  Norte    RO 0.613
## 8   2010  Norte    RO 0.611
## 9   2010  Norte    RO 0.672
## 10  2010  Norte    RO 0.657
## # ... with 5,517 more rows
  # é igual a
  # filter(uf %in% c(&#39;SP&#39;, &#39;MG&#39;) | idhm &amp;gt; .5 &amp;amp; ano == 2010)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(stringr)
pnud_min %&amp;gt;% 
  select(muni, ano, uf) %&amp;gt;% 
  filter(str_detect(muni, &#39;^[HG]|S$&#39;), 
         ano == 1991)
## # A tibble: 970 × 3
##                         muni   ano    uf
##                        &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;
## 1                  ARIQUEMES  1991    RO
## 2                 CEREJEIRAS  1991    RO
## 3              COSTA MARQUES  1991    RO
## 4              GUAJARÁ-MIRIM  1991    RO
## 5    ALTO ALEGRE DOS PARECIS  1991    RO
## 6                    BURITIS  1991    RO
## 7               CASTANHEIRAS  1991    RO
## 8  GOVERNADOR JORGE TEIXEIRA  1991    RO
## 9                    PARECIS  1991    RO
## 10              SERINGUEIRAS  1991    RO
## # ... with 960 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;mutate&#34;&gt;&lt;code&gt;mutate&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Parecido com &lt;code&gt;transform&lt;/code&gt;, mas aceita várias novas colunas iterativamente.&lt;/li&gt;
&lt;li&gt;Novas variáveis devem ter o mesmo &lt;code&gt;length&lt;/code&gt; que o &lt;code&gt;nrow&lt;/code&gt; do bd oridinal ou &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(muni, rdpc, pop, idhm_l, espvida) %&amp;gt;% 
  mutate(renda = rdpc * pop, 
         razao = idhm_l / espvida)
## # A tibble: 16,686 × 7
##                     muni   rdpc   pop idhm_l espvida      renda
##                    &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1  ALTA FLORESTA D&#39;OESTE 198.46 22835  0.617   62.01  4531834.1
## 2              ARIQUEMES 319.47 55018  0.684   66.02 17576600.5
## 3                 CABIXI 116.38  5846  0.636   63.16   680357.5
## 4                 CACOAL 320.24 66534  0.667   65.03 21306848.2
## 5             CEREJEIRAS 240.10 19030  0.629   62.73  4569103.0
## 6      COLORADO DO OESTE 224.82 25070  0.658   64.46  5636237.4
## 7             CORUMBIARA  81.38 10737  0.572   59.32   873777.1
## 8          COSTA MARQUES 250.08  6902  0.629   62.76  1726052.2
## 9        ESPIGÃO D&#39;OESTE 263.03 22505  0.653   64.18  5919490.1
## 10         GUAJARÁ-MIRIM 391.37 31240  0.662   64.71 12226398.8
## # ... with 16,676 more rows, and 1 more variables: razao &amp;lt;dbl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;arrange&#34;&gt;&lt;code&gt;arrange&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Simplesmente ordena de acordo com as opções.&lt;/li&gt;
&lt;li&gt;Utilizar &lt;code&gt;desc&lt;/code&gt; para ordem decrescente.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  filter(ano == 2010) %&amp;gt;% 
  arrange(desc(espvida))
## # A tibble: 5,562 × 14
##      ano               muni    uf regiao  idhm idhm_e idhm_l idhm_r
##    &amp;lt;int&amp;gt;              &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1   2010           BLUMENAU    SC    Sul 0.806  0.722  0.894  0.812
## 2   2010            BRUSQUE    SC    Sul 0.795  0.707  0.894  0.794
## 3   2010 BALNEÁRIO CAMBORIÚ    SC    Sul 0.845  0.789  0.894  0.854
## 4   2010         RIO DO SUL    SC    Sul 0.802  0.727  0.894  0.793
## 5   2010    RANCHO QUEIMADO    SC    Sul 0.753  0.644  0.893  0.743
## 6   2010       RIO DO OESTE    SC    Sul 0.754  0.625  0.892  0.769
## 7   2010             IOMERÊ    SC    Sul 0.795  0.749  0.891  0.754
## 8   2010            JOAÇABA    SC    Sul 0.827  0.771  0.891  0.823
## 9   2010        NOVA TRENTO    SC    Sul 0.748  0.628  0.891  0.749
## 10  2010        PORTO UNIÃO    SC    Sul 0.786  0.724  0.891  0.752
## # ... with 5,552 more rows, and 6 more variables: espvida &amp;lt;dbl&amp;gt;,
## #   rdpc &amp;lt;dbl&amp;gt;, gini &amp;lt;dbl&amp;gt;, pop &amp;lt;int&amp;gt;, lat &amp;lt;dbl&amp;gt;, lon &amp;lt;dbl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;summarise&#34;&gt;&lt;code&gt;summarise&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Retorna um vetor de tamanho &lt;code&gt;1&lt;/code&gt; a partir de uma conta com as variáveis.&lt;/li&gt;
&lt;li&gt;Geralmente é utilizado em conjunto com &lt;code&gt;group_by&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Algumas funções importantes: &lt;code&gt;n()&lt;/code&gt;, &lt;code&gt;n_distinct()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  group_by(regiao, uf) %&amp;gt;% 
  summarise(n = n(), espvida = mean(espvida)) %&amp;gt;% 
  arrange(regiao, desc(espvida))
## Source: local data frame [27 x 4]
## Groups: regiao [5]
## 
##          regiao    uf     n  espvida
##           &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;    &amp;lt;dbl&amp;gt;
## 1  Centro-Oeste    DF     3 73.36000
## 2  Centro-Oeste    GO   735 69.95346
## 3  Centro-Oeste    MS   234 69.94291
## 4  Centro-Oeste    MT   423 69.42915
## 5      Nordeste    CE   552 65.60627
## 6      Nordeste    RN   501 65.11439
## 7      Nordeste    PE   555 64.92721
## 8      Nordeste    BA  1251 64.62361
## 9      Nordeste    SE   225 64.26031
## 10     Nordeste    PI   672 64.04028
## # ... with 17 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  filter(ano == 2010) %&amp;gt;% 
  count(regiao, sort = TRUE) %&amp;gt;% 
  mutate(prop = n / sum(n), prop = scales::percent(prop))
## # A tibble: 5 × 3
##         regiao     n  prop
##          &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;
## 1     Nordeste  1794 32.3%
## 2      Sudeste  1667 30.0%
## 3          Sul  1187 21.3%
## 4 Centro-Oeste   465  8.4%
## 5        Norte   449  8.1%
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;gather&#34;&gt;&lt;code&gt;gather&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Empilha&amp;rdquo; o banco de dados&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(uf, muni, ano, starts_with(&#39;idhm_&#39;)) %&amp;gt;% 
  gather(tipo_idhm, idhm, starts_with(&#39;idhm_&#39;)) %&amp;gt;% 
  arrange(desc(idhm))
## # A tibble: 50,058 × 5
##       uf               muni   ano tipo_idhm  idhm
##    &amp;lt;chr&amp;gt;              &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1     SC BALNEÁRIO CAMBORIÚ  2010    idhm_l 0.894
## 2     SC           BLUMENAU  2010    idhm_l 0.894
## 3     SC            BRUSQUE  2010    idhm_l 0.894
## 4     SC         RIO DO SUL  2010    idhm_l 0.894
## 5     SC    RANCHO QUEIMADO  2010    idhm_l 0.893
## 6     SC       RIO DO OESTE  2010    idhm_l 0.892
## 7     SC             IOMERÊ  2010    idhm_l 0.891
## 8     SC            JOAÇABA  2010    idhm_l 0.891
## 9     SC        NOVA TRENTO  2010    idhm_l 0.891
## 10    SC        PORTO UNIÃO  2010    idhm_l 0.891
## # ... with 50,048 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;spread&#34;&gt;&lt;code&gt;spread&lt;/code&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Joga&amp;rdquo; uma variável nas colunas&lt;/li&gt;
&lt;li&gt;É essencialmente a função inversa de &lt;code&gt;gather&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(muni, uf, ano, starts_with(&#39;idhm_&#39;)) %&amp;gt;% 
  gather(tipo_idhm, idhm, starts_with(&#39;idhm_&#39;)) %&amp;gt;% 
  spread(ano, idhm)
## # A tibble: 16,686 × 6
##                   muni    uf tipo_idhm `1991` `2000` `2010`
## *                &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1      ABADIA DE GOIÁS    GO    idhm_e  0.183  0.386  0.622
## 2      ABADIA DE GOIÁS    GO    idhm_l  0.658  0.765  0.830
## 3      ABADIA DE GOIÁS    GO    idhm_r  0.563  0.623  0.687
## 4  Abadia dos Dourados    MG    idhm_e  0.225  0.387  0.563
## 5  Abadia dos Dourados    MG    idhm_l  0.728  0.799  0.839
## 6  Abadia dos Dourados    MG    idhm_r  0.551  0.616  0.693
## 7            ABADIÂNIA    GO    idhm_e  0.188  0.292  0.579
## 8            ABADIÂNIA    GO    idhm_l  0.656  0.730  0.841
## 9            ABADIÂNIA    GO    idhm_r  0.560  0.598  0.671
## 10              Abaeté    MG    idhm_e  0.180  0.385  0.556
## # ... with 16,676 more rows
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;funções-auxiliares&#34;&gt;Funções auxiliares&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unite&lt;/code&gt; junta duas ou mais colunas usando algum separador (&lt;code&gt;_&lt;/code&gt;, por exemplo).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;separate&lt;/code&gt; faz o inverso de &lt;code&gt;unite&lt;/code&gt;, e uma coluna em várias usando um separador.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pnud_min %&amp;gt;% 
  select(muni, uf, ano, starts_with(&#39;idhm_&#39;)) %&amp;gt;% 
  gather(tipo_idhm, idhm, starts_with(&#39;idhm_&#39;)) %&amp;gt;% 
  separate(tipo_idhm, c(&#39;idhm_nm&#39;, &#39;tipo&#39;), sep = &#39;_&#39;) %&amp;gt;% 
  select(-idhm_nm) %&amp;gt;% 
  filter(ano == 2010) %&amp;gt;% 
  group_by(tipo) %&amp;gt;% 
  summarise(maior = muni[which.max(idhm)], idhm = max(idhm)) %&amp;gt;% 
  arrange(tipo, desc(idhm))
## # A tibble: 3 × 3
##    tipo              maior  idhm
##   &amp;lt;chr&amp;gt;              &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;
## 1     e ÁGUAS DE SÃO PEDRO 0.825
## 2     l BALNEÁRIO CAMBORIÚ 0.894
## 3     r SÃO CAETANO DO SUL 0.891
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;um-pouco-mais-de-transformação-de-dados&#34;&gt;Um pouco mais de transformação de dados&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Para juntar tabelas, usar &lt;code&gt;inner_join&lt;/code&gt;, &lt;code&gt;left_join&lt;/code&gt;, &lt;code&gt;anti_join&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;Para realizar operações mais gerais, usar &lt;code&gt;do&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Para retirar duplicatas, utilizar &lt;code&gt;distinct&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;ol&gt;
&lt;li&gt;Calcule o número de ouro no R.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$$
\frac{1 + \sqrt{5}}{2}
$$&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIERpZ2l0ZSBhIGV4cHJlc3NcdTAwZTNvIHF1ZSBjYWxjdWxhIG8gblx1MDBmYW1lcm8gZGUgb3Vyby4iLCJzb2x1dGlvbiI6IigxICsgc3FydCg1KSkvMiIsInNjdCI6InRlc3Rfb3V0cHV0X2NvbnRhaW5zKFwiMS42MTgwMzRcIiwgaW5jb3JyZWN0X21zZyA9IFwiVGVtIGNlcnRlemEgZGUgcXVlIGluZGljb3UgYSBleHByZXNzXHUwMGUzbyBjb3JyZXRhbWVudGU/XCIpXG5zdWNjZXNzX21zZyhcIkNvcnJldG8hXCIpIn0=&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Stringr</title>
      <link>/stringr/</link>
      <pubDate>Tue, 24 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/stringr/</guid>
      <description>

&lt;p&gt;Variáveis do tipo texto são muito comuns nos bancos de dados e geralmente são
colunas que dão bastante trabalho para serem manipuladas. É muito comun encontrar
bancos de dados em que os textos de uma coluna não estão padronizados, por exemplo
uma coluna &lt;code&gt;Estado&lt;/code&gt; em que são encontrados &amp;ldquo;SP&amp;rdquo;, &amp;ldquo;sp&amp;rdquo;, &amp;ldquo;Sao Paulo&amp;rdquo;, &amp;ldquo;São Paulo&amp;rdquo;, etc
todas as variações indicando o mesmo estado.&lt;/p&gt;

&lt;p&gt;Para manipular esses textos o R possui diversas funções para manipular textos, no entanto,
as funções do &lt;code&gt;base&lt;/code&gt; não possuem um interface consistente e parece que cada uma
tem a sua forma de passar os parâmetros, dificultando o processo durante a análise.&lt;/p&gt;

&lt;p&gt;Por isso, é recomendado usar o pacote &lt;code&gt;stringr&lt;/code&gt; que possui a sintaxe consistente
permitindo que o usuário realize qualquer manipulação com textos com maior facilidade.&lt;/p&gt;

&lt;h3 id=&#34;vantagens-do-stringr-em-relação-ao-base&#34;&gt;Vantagens do stringr em relação ao base&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Sintaxe unificada, o que auxilia na memorização e leitura do código.&lt;/li&gt;
&lt;li&gt;Todas as funções são vetorizadas.&lt;/li&gt;
&lt;li&gt;Construído sobre a &lt;a href=&#34;http://site.icu-project.org/&#34;&gt;biblioteca ICU&lt;/a&gt;, implementada em &lt;code&gt;C&lt;/code&gt; e &lt;code&gt;C++&lt;/code&gt;, apresentando resultados rápidos e confiáveis.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;regras-básicas-do-pacote&#34;&gt;Regras básicas do pacote&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;As funções de manipulação de texto começam com &lt;code&gt;str_&lt;/code&gt;. Caso esqueça o nome de uma função, basta digitar &lt;code&gt;stringr::str_&lt;/code&gt; e apertar &lt;code&gt;TAB&lt;/code&gt; para ver quais são as opções.&lt;/li&gt;
&lt;li&gt;O primeiro argumento da função é sempre uma &lt;code&gt;string&lt;/code&gt; ou um vetor de &lt;code&gt;strings&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;curiosidade&#34;&gt;Curiosidade&lt;/h3&gt;

&lt;p&gt;Inicialmente, o &lt;code&gt;stringr&lt;/code&gt; era um &lt;em&gt;wrapper&lt;/em&gt; de funções do &lt;code&gt;base&lt;/code&gt;. Depois disso,
surgiu um novo pacote &lt;code&gt;stringi&lt;/code&gt;, com sintaxe similar ao &lt;code&gt;stringr&lt;/code&gt;, mas funcionando como
&lt;em&gt;wrapper&lt;/em&gt; da biblioteca ICU. No entanto, Wickham gostou tanto do pacote &lt;code&gt;stringi&lt;/code&gt;
que decidiu reescrever o &lt;code&gt;stringr&lt;/code&gt; como um &lt;em&gt;wrapper&lt;/em&gt; do &lt;code&gt;stringi&lt;/code&gt;.
Veja &lt;a href=&#34;https://github.com/tidyverse/stringr/blob/master/NEWS.md&#34;&gt;essa página&lt;/a&gt; para detalhes.&lt;/p&gt;

&lt;h2 id=&#34;conceitos-básicos&#34;&gt;Conceitos básicos&lt;/h2&gt;

&lt;p&gt;Todas as funções do &lt;code&gt;stringr&lt;/code&gt; começam com o prefixo &lt;code&gt;str&lt;/code&gt;, isso ajuda na hora de
encontrar a função que você está procurando. No Rstudio, basta digitar &lt;code&gt;str_&lt;/code&gt; e
apertar tab que você verá algo parecido com a imagem a baixo. Você pode ir descendo
com as setas do teclado e ver o que cada função faz até encontrar a função que estava
procurando.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;figures/str_tab.png&#34; alt=&#34;str_tab&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nesta sessão vamos utilizar as funções mais simples do &lt;code&gt;stringr&lt;/code&gt;, depois vamos
ensinar um pouco de Regex e em seguida veremos as funções mais avançadas do
pacote.&lt;/p&gt;

&lt;h3 id=&#34;str-length&#34;&gt;str_length&lt;/h3&gt;

&lt;p&gt;A função mais simples do &lt;code&gt;stringr&lt;/code&gt; é a função &lt;code&gt;str_length&lt;/code&gt;. Esta função recebe
apenas uma string como argumento e retorna o número de caracteres. Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(stringr)
str_length(&amp;quot;olá&amp;quot;)
## [1] 3
length(&amp;quot;olá&amp;quot;)
## [1] 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja &lt;code&gt;str_length&lt;/code&gt; é diferente de &lt;code&gt;length&lt;/code&gt;. O primeiro retorna o número de caracteres
e o segundo retorna o comprimento do objeto. Isso fica mais claro no seguinte exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s &amp;lt;- c(&amp;quot;olá mundo&amp;quot;, &amp;quot;olá universo&amp;quot;)
str_length(s)
## [1]  9 12
length(s)
## [1] 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora o &lt;code&gt;str_length&lt;/code&gt; retornou um vetor com o número de caracteres de cada elemento do vetor &lt;code&gt;s&lt;/code&gt;,
e o &lt;code&gt;length&lt;/code&gt; retornou o comprimento do vetor &lt;code&gt;s&lt;/code&gt;. Note que espaço é considerado como um caractere.&lt;/p&gt;

&lt;h3 id=&#34;str-trim&#34;&gt;str_trim&lt;/h3&gt;

&lt;p&gt;É muito comum encontrar textos que vêm com espaços a mais, principalmente de dados
provenientes de formulários em que cada usuário escreve da forma que prefere.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;string &amp;lt;- &#39;\nessa      string é muito suja       \n&#39;
str_trim(string)
## [1] &amp;quot;essa      string é muito suja&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A função &lt;code&gt;str_trim&lt;/code&gt; ajuda removendo os espaços excedetes antes e depois da string.&lt;/p&gt;

&lt;h3 id=&#34;str-sub&#34;&gt;str_sub&lt;/h3&gt;

&lt;p&gt;As vezes você precisa obter alguma parte fixa de uma string. Por exemplo, as vezes você
encontra variáveis com valores da forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s &amp;lt;- c(&amp;quot;01-Feminino&amp;quot;, &amp;quot;02-Masculino&amp;quot;, &amp;quot;03-Indefinido&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Você pode querer manipular essa string para retirar obter apenas a parte final da string.
Neste caso pode usar a função &lt;code&gt;str_sub&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_sub(s, start = 4) # pegar do quarto até o último caractere
## [1] &amp;quot;Feminino&amp;quot;   &amp;quot;Masculino&amp;quot;  &amp;quot;Indefinido&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É possível obter também apenas os números&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_sub(s, end = 2) # pegar apenas os dois primeiros caracteres
## [1] &amp;quot;01&amp;quot; &amp;quot;02&amp;quot; &amp;quot;03&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Em outros casos você precisa obter os últimos 2 caracteres.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s &amp;lt;- c(&amp;quot;Feminino-01&amp;quot;, &amp;quot;Masculino-02&amp;quot;, &amp;quot;Indefinido-03&amp;quot;)
str_sub(s, end = -4)
## [1] &amp;quot;Feminino&amp;quot;   &amp;quot;Masculino&amp;quot;  &amp;quot;Indefinido&amp;quot;
str_sub(s, start = -2)
## [1] &amp;quot;01&amp;quot; &amp;quot;02&amp;quot; &amp;quot;03&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É possível também usar os argumentos &lt;code&gt;start&lt;/code&gt; e &lt;code&gt;end&lt;/code&gt; conjuntamente.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s &amp;lt;- c(&amp;quot;__SP__&amp;quot;, &amp;quot;__MG__&amp;quot;, &amp;quot;__RJ__&amp;quot;)
str_sub(s, 3, 4)
## [1] &amp;quot;SP&amp;quot; &amp;quot;MG&amp;quot; &amp;quot;RJ&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;str-to-upper-str-to-lower-str-to-title&#34;&gt;str_to_upper, str_to_lower, str_to_title&lt;/h3&gt;

&lt;p&gt;Essas funções servem para modificar a caixa das letras. Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;s &amp;lt;- &amp;quot;Olá, tudo bem?&amp;quot;
str_to_lower(s)
## [1] &amp;quot;olá, tudo bem?&amp;quot;
str_to_upper(s)
## [1] &amp;quot;OLÁ, TUDO BEM?&amp;quot;
str_to_title(s)
## [1] &amp;quot;Olá, Tudo Bem?&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essas são as funções mais simples do pacote &lt;code&gt;stringr&lt;/code&gt; e mão exigem nenhum conhecimento
de regex. Note que nenhuma delas possui o parâmetro &lt;code&gt;pattern&lt;/code&gt;, você verá como especificar
esse parâmetros nas próximas sessões.&lt;/p&gt;

&lt;h2 id=&#34;expressões-regulares&#34;&gt;Expressões Regulares&lt;/h2&gt;

&lt;p&gt;Trabalhar com textos exige um certo conhecimento de expressões regulares (&lt;em&gt;regex&lt;/em&gt;).
&lt;a href=&#34;https://pt.wikipedia.org/wiki/Express%C3%A3o_regular&#34;&gt;Expressões regulares&lt;/a&gt; permitem
identificar conjuntos de caracters, palavras, e outros padrões por meio de uma sintaxe
concisa.&lt;/p&gt;

&lt;p&gt;O &lt;code&gt;stringr&lt;/code&gt; utiliza regex da forma descrita &lt;a href=&#34;http://www.gagolewski.com/software/stringi/manual/?manpage=stringi-search-regex&#34;&gt;neste documento&lt;/a&gt;.
A própria &lt;a href=&#34;https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html&#34;&gt;definição&lt;/a&gt; de
regex do R é um ótimo manual.&lt;/p&gt;

&lt;p&gt;Vamos estudar expressões regulares através de exemplos e com a função &lt;code&gt;str_detect()&lt;/code&gt;.
Essa função retorna &lt;code&gt;TRUE&lt;/code&gt; se uma string atende à uma expressão regular e &lt;code&gt;FALSE&lt;/code&gt;
em caso contrário.&lt;/p&gt;

&lt;p&gt;Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(stringr)
str_detect(&amp;quot;sao paulo&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)
## [1] TRUE
str_detect(&amp;quot;sao paulo sp&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)
## [1] FALSE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A regex/pattern &amp;ldquo;paulo$&amp;rdquo; indica que o texto deve ser terminado em &amp;ldquo;paulo&amp;rdquo;. Existem
diversos de caracteres auxiliares que vão auxiliar na manipulação dos textos, assim como
o &amp;ldquo;$&amp;rdquo; neste caso. É importante notar que sempre que você estiver passando algum
valor para o argumento &lt;code&gt;pattern&lt;/code&gt; de qualquer função do &lt;code&gt;stringr&lt;/code&gt; ele o entenderá
como uma regex.&lt;/p&gt;

&lt;p&gt;A tabela abaixo mostra a aplicação de seis &lt;code&gt;regex&lt;/code&gt; a seis strings distintas.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;testes&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;^ban&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;b ?an&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;ban&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;BAN&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;ban$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;abandonado&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ban&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;banana&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;BANANA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ele levou ban&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;pranab anderson&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TRUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FALSE&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;quantificadores&#34;&gt;Quantificadores&lt;/h3&gt;

&lt;p&gt;Os caracteres &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; e &lt;code&gt;{x,y}&lt;/code&gt; indicam quantas vezes um padrão se repete:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ey+&lt;/code&gt; significa &lt;code&gt;e&lt;/code&gt; e depois &lt;code&gt;y&lt;/code&gt; &amp;ldquo;&lt;strong&gt;uma vez&lt;/strong&gt; ou mais&amp;rdquo;. Por exemplo, reconhece &lt;code&gt;hey&lt;/code&gt;, &lt;code&gt;heyy&lt;/code&gt;, &lt;code&gt;a eyyy&lt;/code&gt;, mas não reconhece &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; nem &lt;code&gt;yy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ey*&lt;/code&gt; significa &amp;ldquo;&lt;strong&gt;zero vezes&lt;/strong&gt; ou mais&amp;rdquo;. Por exemplo, reconhece &lt;code&gt;hey&lt;/code&gt;, &lt;code&gt;heyy&lt;/code&gt;, &lt;code&gt;a eyyy&lt;/code&gt; e &lt;code&gt;e&lt;/code&gt;, mas não reconhece &lt;code&gt;y&lt;/code&gt; nem &lt;code&gt;yy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ey{3}&lt;/code&gt; significa &amp;ldquo;exatamente três vezes&amp;rdquo;. Por exemplo, reconhece &lt;code&gt;eyyy&lt;/code&gt; e &lt;code&gt;eyyyy&lt;/code&gt;, mas não reconhece &lt;code&gt;eyy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ey{1,3}&lt;/code&gt; significa &amp;ldquo;entre uma e três vezes&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para aplicar um quantificador a um conjunto de caracteres, use parênteses. Por exemplo, &lt;code&gt;(ey )+&lt;/code&gt; reconhece &lt;code&gt;ey ey&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;conjuntos&#34;&gt;Conjuntos&lt;/h3&gt;

&lt;p&gt;Colocando caracteres dentro de &lt;code&gt;[]&lt;/code&gt;, reconhecemos quaisquer caracteres desse conjunto. Alguns exemplos práticos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[Cc]asa&lt;/code&gt; para reconhecer &amp;ldquo;casa&amp;rdquo; em maiúsculo ou minúsculo.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9]&lt;/code&gt; para reconhecer somente números. O mesmo vale para letras &lt;code&gt;[a-z]&lt;/code&gt;, &lt;code&gt;[A-Z]&lt;/code&gt;, &lt;code&gt;[a-zA-Z]&lt;/code&gt; etc.&lt;/li&gt;
&lt;li&gt;O símbolo &lt;code&gt;^&lt;/code&gt; dentro do colchete significa negação. Por exemplo, &lt;code&gt;[^0-9]&lt;/code&gt; significa pegar tudo o que não é número.&lt;/li&gt;
&lt;li&gt;O símbolo &lt;code&gt;.&lt;/code&gt; fora do colchete indica &amp;ldquo;qualquer caractere&amp;rdquo;, mas dentro do colchete é apenas ponto.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;[[:space:]]+&lt;/code&gt; para reconhecer espaços e &lt;code&gt;[[:punct:]]+&lt;/code&gt; para reconhecer pontuações.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;miscelânea&#34;&gt;Miscelânea&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;abjutils::rm_accent()&lt;/code&gt; para retirar os acentos de um texto.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;|&lt;/code&gt; para opções, por exemplo &lt;code&gt;desfavor|desprov&lt;/code&gt; reconhece tanto &amp;ldquo;desfavorável&amp;rdquo; quanto &amp;ldquo;desprovido&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\n&lt;/code&gt; pula linha, &lt;code&gt;\f&lt;/code&gt; é final da página, &lt;code&gt;\t&lt;/code&gt; é tab. Use &lt;code&gt;\&lt;/code&gt; para transformar caracteres especiais em literais.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tolower()&lt;/code&gt; e &lt;code&gt;toupper()&lt;/code&gt; para mudar o case de uma string.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A lista de possibilidades com expressões regulares é extensa.
Um bom lugar para testar o funcionamento de expressões regulares é o &lt;a href=&#34;https://regex101.com/&#34;&gt;regex101&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;funções-avançadas&#34;&gt;Funções avançadas&lt;/h2&gt;

&lt;p&gt;Agora que já vimos as funções básicas do &lt;code&gt;stringr&lt;/code&gt;, e aprendemos um pouco de regex,
vamos às funções mais avançadas. Basicmante, essas funções buscarão &lt;code&gt;patterns&lt;/code&gt; em
um vetor de strings e farão alguma coisa quando encontrá-lo.&lt;/p&gt;

&lt;p&gt;Como já vimos na sessão sobre regex, a função mais simples que possui o argumento
&lt;code&gt;pattern&lt;/code&gt; é a &lt;code&gt;str_detect&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;str-detect&#34;&gt;str_detect()`&lt;/h3&gt;

&lt;p&gt;Retorna &lt;code&gt;TRUE&lt;/code&gt; se a regex é compatível com a string e &lt;code&gt;FALSE&lt;/code&gt; caso contrário.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(stringr)
str_detect(&amp;quot;sao paulo&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)
## [1] TRUE
str_detect(&amp;quot;sao paulo sp&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)
## [1] FALSE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;str-replace-e-str-replace-all&#34;&gt;str_replace() e str_replace_all()&lt;/h3&gt;

&lt;p&gt;Substituem um padrão (ou todos) encontrado para um outro padrão&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;frutas &amp;lt;- c(&amp;quot;uma maçã&amp;quot;, &amp;quot;duas pêras&amp;quot;, &amp;quot;três bananas&amp;quot;)
str_replace(frutas, &amp;quot;[aeiou]&amp;quot;, &amp;quot;-&amp;quot;) # substitui a primeira vogal de cada string por &amp;quot;-&amp;quot;
## [1] &amp;quot;-ma maçã&amp;quot;     &amp;quot;d-as pêras&amp;quot;   &amp;quot;três b-nanas&amp;quot;
str_replace_all(frutas, &amp;quot;[aeiou]&amp;quot;, &amp;quot;-&amp;quot;) # substitui todas as vogais por &amp;quot;-&amp;quot;
## [1] &amp;quot;-m- m-çã&amp;quot;     &amp;quot;d--s pêr-s&amp;quot;   &amp;quot;três b-n-n-s&amp;quot;

yyyy &amp;lt;- &amp;quot;yyyyy yyyyy ll zz&amp;quot;
str_replace(yyyy, &#39;y+&#39;, &#39;x&#39;) # substitui o primeiro 1 ou mais y&#39;s por x
## [1] &amp;quot;x yyyyy ll zz&amp;quot;
str_replace_all(yyyy, &#39;y+&#39;, &#39;x&#39;) # substitui todos os 1 ou mais y por somente 1 x
## [1] &amp;quot;x x ll zz&amp;quot;
str_replace_all(yyyy, &#39;y&#39;, &#39;x&#39;) # substitui y por x
## [1] &amp;quot;xxxxx xxxxx ll zz&amp;quot;

str_replace_all(&#39;string     com    muitos espaços&#39;, &#39; +&#39;, &#39; &#39;) # tirar espaços extras
## [1] &amp;quot;string com muitos espaços&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muitas vezes queremos remover alguns caracteres especiais de um texto, mas esses
caracteres fazem parte de comandos de regex, por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;string &amp;lt;- &amp;quot;1 + 2 + 5&amp;quot;
str_replace_all(string, &amp;quot;+&amp;quot;, &amp;quot;-&amp;quot;)
## Error in stri_replace_all_regex(string, pattern, fix_replacement(replacement), : Syntax error in regexp pattern. (U_REGEX_RULE_SYNTAX)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essa forma retorna um erro, pois a função tenta montar uma regex. Você poderia
tentar de outras formas, que não retornariam erro, mas também não retornariam o
resultado esperado.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_replace_all(string, &amp;quot; + &amp;quot;, &amp;quot; - &amp;quot;)
## [1] &amp;quot;1 + 2 + 5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesse caso, use a função &lt;code&gt;fixed&lt;/code&gt; para indicar para o &lt;code&gt;stringr&lt;/code&gt; que você não deseja
que o parâmetro seja reconhecido como uma regex.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_replace_all(string, fixed(&amp;quot;+&amp;quot;), &amp;quot;-&amp;quot;)
## [1] &amp;quot;1 - 2 - 5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;str-extract-e-str-extract-all&#34;&gt;str_extract() e str_extract_all()&lt;/h3&gt;

&lt;p&gt;Extraem padrões de uma string. Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;r_core_group &amp;lt;- c(
  &#39;Douglas Bates&#39;, &#39;John Chambers&#39;, &#39;Peter Dalgaard&#39;,
  &#39;Robert Gentleman&#39;, &#39;Kurt Hornik&#39;, &#39;Ross Ihaka&#39;, &#39;Tomas Kalibera&#39;,
  &#39;Michael Lawrence&#39;, &#39;Friedrich Leisch&#39;, &#39;Uwe Ligges&#39;, &#39;...&#39;
)
sobrenomes &amp;lt;- str_extract(r_core_group, &#39;[:alpha:]+$&#39;)
sobrenomes
##  [1] &amp;quot;Bates&amp;quot;     &amp;quot;Chambers&amp;quot;  &amp;quot;Dalgaard&amp;quot;  &amp;quot;Gentleman&amp;quot; &amp;quot;Hornik&amp;quot;   
##  [6] &amp;quot;Ihaka&amp;quot;     &amp;quot;Kalibera&amp;quot;  &amp;quot;Lawrence&amp;quot;  &amp;quot;Leisch&amp;quot;    &amp;quot;Ligges&amp;quot;   
## [11] NA
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;str-match-e-str-match-all&#34;&gt;str_match() e str_match_all()&lt;/h3&gt;

&lt;p&gt;Extrai pedaços da string identificados pela regex. Caso queira extrair
somente a parte identificada, use parênteses. Isso é útil quando você
está interessado em uma parte do padrão, mas para identificá-lo precisa&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Exemplo de pergunta SOPt: http://pt.stackoverflow.com/q/150024/6036
presidentes &amp;lt;- c(&amp;quot;da Fonseca, DeodoroDeodoro da Fonseca&amp;quot;, 
&amp;quot;Peixoto, FlorianoFloriano Peixoto&amp;quot;, &amp;quot;de Morais, PrudentePrudente de Morais&amp;quot;, 
&amp;quot;Sales, CamposCampos Sales&amp;quot;)
nomes_presidentes &amp;lt;- str_match(presidentes, &#39;(.*), ([a-zA-Z]{1,})[A-Z]{1}&#39;)
nomes_presidentes
##      [,1]                   [,2]         [,3]      
## [1,] &amp;quot;da Fonseca, DeodoroD&amp;quot; &amp;quot;da Fonseca&amp;quot; &amp;quot;Deodoro&amp;quot; 
## [2,] &amp;quot;Peixoto, FlorianoF&amp;quot;   &amp;quot;Peixoto&amp;quot;    &amp;quot;Floriano&amp;quot;
## [3,] &amp;quot;de Morais, PrudenteP&amp;quot; &amp;quot;de Morais&amp;quot;  &amp;quot;Prudente&amp;quot;
## [4,] &amp;quot;Sales, CamposC&amp;quot;       &amp;quot;Sales&amp;quot;      &amp;quot;Campos&amp;quot;
str_c(nomes_presidentes[,3], nomes_presidentes[,2], sep = &#39; &#39;)
## [1] &amp;quot;Deodoro da Fonseca&amp;quot; &amp;quot;Floriano Peixoto&amp;quot;   &amp;quot;Prudente de Morais&amp;quot;
## [4] &amp;quot;Campos Sales&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;str-split-e-str-split-fixed&#34;&gt;str_split() e str_split_fixed()&lt;/h3&gt;

&lt;p&gt;Separa uma string em várias de acordo com um separador.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;string &amp;lt;- &#39;Durante um longo período de tempo o &amp;quot;R&amp;quot; foi escrito &amp;quot;P&amp;quot; como no alfabeto cirílico. O seu nome no alfabeto fenício era &amp;quot;rech&amp;quot;. Seu significado era o de uma cabeça, representada pela adaptação do hieróglifo egípcio de uma cabeça. Transformou-se no &amp;quot;rô&amp;quot; dos gregos. Os romanos modificaram o rô acrescentando um pequeno traço para diferenciá-lo do no nosso P.&#39;
str_split(string, fixed(&#39;.&#39;))
## [[1]]
## [1] &amp;quot;Durante um longo período de tempo o \&amp;quot;R\&amp;quot; foi escrito \&amp;quot;P\&amp;quot; como no alfabeto cirílico&amp;quot;                
## [2] &amp;quot; O seu nome no alfabeto fenício era \&amp;quot;rech\&amp;quot;&amp;quot;                                                         
## [3] &amp;quot; Seu significado era o de uma cabeça, representada pela adaptação do hieróglifo egípcio de uma cabeça&amp;quot;
## [4] &amp;quot; Transformou-se no \&amp;quot;rô\&amp;quot; dos gregos&amp;quot;                                                                 
## [5] &amp;quot; Os romanos modificaram o rô acrescentando um pequeno traço para diferenciá-lo do no nosso P&amp;quot;         
## [6] &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O &lt;code&gt;str_split_fixed&lt;/code&gt; faz o mesmo que &lt;code&gt;str_split()&lt;/code&gt;, mas separa apenas &lt;code&gt;n&lt;/code&gt; vezes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str_split_fixed(string, fixed(&#39;.&#39;), 3)
##      [,1]                                                                                   
## [1,] &amp;quot;Durante um longo período de tempo o \&amp;quot;R\&amp;quot; foi escrito \&amp;quot;P\&amp;quot; como no alfabeto cirílico&amp;quot;
##      [,2]                                          
## [1,] &amp;quot; O seu nome no alfabeto fenício era \&amp;quot;rech\&amp;quot;&amp;quot;
##      [,3]                                                                                                                                                                                                                                      
## [1,] &amp;quot; Seu significado era o de uma cabeça, representada pela adaptação do hieróglifo egípcio de uma cabeça. Transformou-se no \&amp;quot;rô\&amp;quot; dos gregos. Os romanos modificaram o rô acrescentando um pequeno traço para diferenciá-lo do no nosso P.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;str-subset&#34;&gt;str_subset()&lt;/h3&gt;

&lt;p&gt;Retorna somente as strings compatíveis com a regex.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;frases &amp;lt;- c(&#39;a roupa do rei&#39;, &#39;de roma&#39;, &#39;o rato roeu&#39;)
str_subset(frases, &#39;d[eo]&#39;)
## [1] &amp;quot;a roupa do rei&amp;quot; &amp;quot;de roma&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É o mesmo que fazer o subset do R e a função &lt;code&gt;str_detect&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;frases[str_detect(frases, &amp;quot;d[eo]&amp;quot;)]
## [1] &amp;quot;a roupa do rei&amp;quot; &amp;quot;de roma&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;exercícios&#34;&gt;Exercícios&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Faça uma regex que capture múltiplas versões da palavra &amp;lsquo;casa&amp;rsquo;. Ela deve funcionar
com as palavras &amp;lsquo;Casa&amp;rsquo;, &amp;lsquo;CASA&amp;rsquo;, &amp;lsquo;CaSa&amp;rsquo;, &amp;lsquo;CAsa&amp;rsquo;. Teste-a usando a função &lt;code&gt;str_detect&lt;/code&gt;.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KHN0cmluZ3IpXG5wYWxhdnJhcyA8LSBjKCdDYXNhJywgJ0NBU0EnLCAnQ2FTYScsICdDQXNhJylcbnN0cl9kZXRlY3QocGFsYXZyYXMsIHBhdHRlcm4gPSBfc3VhX3JlZ2V4XykiLCJzb2x1dGlvbiI6ImxpYnJhcnkoc3RyaW5ncilcbnBhbGF2cmFzIDwtIGMoJ0Nhc2EnLCAnQ0FTQScsICdDYVNhJywgJ0NBc2EnKVxuc3RyX2RldGVjdChwYWxhdnJhcywgcmVnZXgoJ2Nhc2EnLCBpZ25vcmVfY2FzZSA9IFRSVUUpKSIsInNjdCI6InRlc3Rfc3R1ZGVudF90eXBlZChcInN0cl9kZXRlY3RcIiwgbm90X3R5cGVkX21zZyA9ICdVc2Ugc3RyX2RldGVjdCEnKVxudGVzdF9leHByZXNzaW9uX3Jlc3VsdChjKFRSVUUsIFRSVUUsIFRSVUUsIFRSVUUpLCBpbmNvcnJlY3RfbXNnID0gXCJVc2UgYSBmdW5cdTAwZTdcdTAwZTNvIHN0cl9kZXRlY3RcIilcbnN1Y2Nlc3NfbXNnKFwiQ29ycmV0byFcIikifQ==&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; Imagine que você possui a seguinte string que é a parte final de uma URL:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/ac/rio-branco/xpto-xyz-1-0-1fds2396-5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Você precisa transformá-la em &amp;lsquo;AC - Rio Branco&amp;rsquo;. &lt;strong&gt;Dica&lt;/strong&gt;: Use a função &lt;code&gt;str_split&lt;/code&gt;.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJsaWJyYXJ5KHN0cmluZ3IpXG51cmwgPC0gYygnL2FjL3Jpby1icmFuY28veHB0by14eXotMS0wLTFmZHMyMzk2LTUnKSIsInNvbHV0aW9uIjoibGlicmFyeShzdHJpbmdyKVxudXJsIDwtIGMoJy9hYy9yaW8tYnJhbmNvL3hwdG8teHl6LTEtMC0xZmRzMjM5Ni01JylcbmF1eCA8LSBzdHJfc3BsaXQodXJsLCAnLycsIHNpbXBsaWZ5ID0gVFJVRSlcbmF1eFsyXSA8LSBzdHJfdG9fdXBwZXIoYXV4WzJdKVxuYXV4WzNdIDwtIHN0cl9yZXBsYWNlX2FsbChhdXhbM10sICctJywgJyAnKSAlPiUgc3RyX3RvX3RpdGxlKClcbmxvY2FsaXphY2FvIDwtIHN0cl9jKGF1eFsyXSwgYXV4WzNdLCBzZXAgPSAnIC0gJykgIiwic2N0IjoidGVzdF9vYmplY3QoJ2xvY2FsaXphY2FvJywgdW5kZWZpbmVkX21zZyA9ICdEZWZpbmEgbyBvYmpldG8gbG9jYWxpemFjYW8nLCBpbmNvcnJlY3RfbXNnID0gJ2xvY2FsaXphY2FvIG5cdTAwZTNvIGVzdFx1MDBlMSBjb20gbyByZXN1bHRhZG8gZXNwZXJhZG8nKVxuc3VjY2Vzc19tc2coXCJDb3JyZXRvIVwiKSJ9&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; Você possui o seguinte vetor de caracteres: &lt;code&gt;x &amp;lt;- c(&#39;Alto&#39;, &#39;Médio&#39;, &#39;Baixo&#39;)&lt;/code&gt;. A partir desse vetor,
crie um vetor com os valores `&amp;lsquo;03 - Alto&amp;rsquo;, &amp;lsquo;02 - Médio&amp;rsquo; e &amp;lsquo;03 - Baixo&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; Crie uma função que retorna &lt;code&gt;TRUE&lt;/code&gt; quando a string é um &lt;a href=&#34;https://pt.wikipedia.org/wiki/Pal%C3%ADndromo&#34;&gt;palíndromo&lt;/a&gt; e &lt;code&gt;FALSO&lt;/code&gt; caso não seja.
&lt;em&gt;Palíndromo&lt;/em&gt; é uma sequência que é lida da mesma forma tanto da direita pra esquerda quanto
da esquerda para a direita. O nome &amp;lsquo;Ana&amp;rsquo;, por exemplo, é um palíndromo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; De acordo com as regras da língua portuguesa, antes de “P” ou “B” devemos usar a letra “M”. Em outras palavras, com outras consoantes, usamos a letra “N”. Suponha que você tem o seguinte
texto com erros gramaticais.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ0ZXh0byA8LSAnTlx1MDBmM3MgY2hhbWFtb3Mgb3MgYm9uYmVpcm9zIHF1YW5kbyBjb21lXHUwMGU3b3UgbyBpbmNcdTAwZWFuZGlvLicifQ==&lt;/div&gt;

&lt;p&gt;Crie uma função para corrigí-lo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; O CPF é um número de 11 dígitos, por exemplo: 54491651884. No entanto para facilitar
a visualização costumamos mostrá-lo com separadores a cada 3 casas: 544.916.518-84.
Crie uma função que transforma um número de 11 dígitos em uma string com as separações, como um CPF.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ggplot</title>
      <link>/ggplot/</link>
      <pubDate>Mon, 23 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/ggplot/</guid>
      <description>

&lt;p&gt;Para este tópico vamos utilizar o &lt;code&gt;ggplot2&lt;/code&gt;. O &lt;code&gt;ggplot2&lt;/code&gt; é um pacote do R voltado
para a criação de gráficos estatísticos. Ele é baseado na Gramática dos Gráficos
(&lt;em&gt;grammar of graphics&lt;/em&gt;, em inglês), criado por Leland Wilkinson, que é uma
resposta para a pergunta: o que é um gráfico estatístico? Resumidamente, a gramática
diz que um gráfico estatístico é um mapeamento dos dados a partir de atributos
estéticos (cores, formas, tamanho) em formas geométricas (pontos, linhas, barras).&lt;/p&gt;

&lt;p&gt;Para mais informações sobre a Gramática dos Gráficos, você pode consultar o livro
&lt;a href=&#34;http://www.springer.com/statistics/computational+statistics/book/978-0-387-24544-7&#34;&gt;&lt;em&gt;The Grammar of graphics&lt;/em&gt;&lt;/a&gt;,
escrito pelo Leland Wilkinson, ou o livro &lt;a href=&#34;http://ggplot2.org/book/&#34;&gt;ggplot2: elegant graphics for data analysis&lt;/a&gt;, do Hadley Wickham.
Um &lt;a href=&#34;http://moderngraphics11.pbworks.com/f/ggplot2-Book09hWickham.pdf&#34;&gt;pdf do livro&lt;/a&gt; também está disponível.&lt;/p&gt;

&lt;p&gt;Para quem quiser se aprofundar mais com o &lt;code&gt;ggplot2&lt;/code&gt;, o &lt;a href=&#34;https://www.datacamp.com/&#34;&gt;DataCamp&lt;/a&gt; possui dois cursos
focados em visualização. É possível começar o curso gratuitamente, mas para terminar,
tem que pagar.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.datacamp.com/courses/data-visualization-with-ggplot2-1&#34;&gt;Data Visualization with ggplot2 (Part 1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.datacamp.com/courses/data-visualization-with-ggplot2-2&#34;&gt;Data Visualization with ggplot2 (Part 2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Antes de começar, instale o pacote digitando &lt;code&gt;install.packages(&amp;quot;ggplot2&amp;quot;)&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;banco-de-dados&#34;&gt;Banco de dados&lt;/h2&gt;

&lt;p&gt;A seguir, vamos discutir os aspectos básicos para a construção de gráficos com o
pacote &lt;code&gt;ggplot2&lt;/code&gt;. Para isso, utilizaremos o banco de dados contido no objeto &lt;code&gt;mtcars&lt;/code&gt;.
Para visualizar as primeiras linhas deste banco, utilize o comando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;head(mtcars)
##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O &lt;code&gt;mtcars&lt;/code&gt; é um banco de dados de 1974 extraído da revista &lt;em&gt;Motor Trend US&lt;/em&gt; que
compreende consumo de combustível e outros 10 aspectos de performance e engenharia
de 32 automóveis.&lt;/p&gt;

&lt;p&gt;Entre as variáveis deste banco de dados estão:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mpg&lt;/code&gt;: consumo de combustível (milhas por galão)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;disp&lt;/code&gt;: cilindrada, que é o &lt;a href=&#34;https://pt.wikipedia.org/wiki/Cilindrada&#34;&gt;volume de deslocamento do motor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para saber mais sobre o &lt;code&gt;mtcarts&lt;/code&gt;, digite &lt;code&gt;help(mtcars)&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;as-camadas-de-um-gráfico&#34;&gt;As camadas de um gráfico&lt;/h2&gt;

&lt;p&gt;Antes de mais nada, vamos carregar o &lt;code&gt;ggplot2&lt;/code&gt; usando:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No &lt;code&gt;ggplot2&lt;/code&gt;, os gráficos são construídos camada por camada (ou, &lt;em&gt;layers&lt;/em&gt;, em inglês),
sendo que a primeira delas é dada pela função &lt;code&gt;ggplot&lt;/code&gt; (não tem o &amp;ldquo;2&amp;rdquo;). Cada camada
representa um tipo de mapeamento ou personalização do gráfico. O código abaixo é um
exemplo de um gráfico bem simples, construído a partir das duas principais camadas.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(data = mtcars) + 
  geom_point(mapping = aes(x = disp, y = mpg))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//grafico1-1.png&#34; title=&#34;plot of chunk grafico1&#34; alt=&#34;plot of chunk grafico1&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Observe que o primeiro argumento da função &lt;code&gt;ggplot&lt;/code&gt; é um data frame. A função &lt;code&gt;aes()&lt;/code&gt;
descreve como as variáveis são mapeadas em aspectos visuais de formas geométricas
definidas pelos &lt;em&gt;geoms&lt;/em&gt;. Aqui, essas formas geométricas são pontos, selecionados pela
função &lt;code&gt;geom_point()&lt;/code&gt;, gerando, assim, um gráfico de dispersão. A combinação dessas
duas camadas define o tipo de gráfico que você deseja construir.&lt;/p&gt;

&lt;h2 id=&#34;aesthetics&#34;&gt;Aesthetics&lt;/h2&gt;

&lt;p&gt;A primeira camada de um gráfico deve indicar a relação entre os dados e cada aspecto
visual do gráfico, como qual variável será representada no eixo x, qual será
representada no eixo y, a cor e o tamanho dos componentes geométricos etc. Os aspectos
que podem ou devem ser mapeados depende do tipo de gráfico que você deseja fazer.&lt;/p&gt;

&lt;p&gt;No exemplo acima, atribuímos aspectos de posição: ao eixo y mapeamos a variável &lt;code&gt;mpg&lt;/code&gt;
(milhas por galão) e ao eixo x a variável &lt;code&gt;disp&lt;/code&gt; (cilindradas). Outro aspecto que pode
ser mapeado nesse gráfico é a cor dos pontos&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(data = mtcars) + 
  geom_point(mapping = aes(x = disp, y = mpg, colour = as.factor(am)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//mapear_am-1.png&#34; title=&#34;plot of chunk mapear_am&#34; alt=&#34;plot of chunk mapear_am&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora, a variável &lt;code&gt;am&lt;/code&gt; (tipo de transmissão) foi mapeada à cor dos pontos, sendo que pontos vermelhos correspondem à transmissão automática (valor 0) e pontos azuis à transmissão manual (valor 1). Observe que inserimos a variável &lt;code&gt;am&lt;/code&gt; como um fator, pois temos interesse apenas nos valores &amp;ldquo;0&amp;rdquo; e &amp;ldquo;1&amp;rdquo;. No entanto, tambem podemos mapear uma variável contínua à cor dos pontos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars) + 
  geom_point(mapping = aes(x = disp, y = mpg, colour = cyl))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//mapear_cor-1.png&#34; title=&#34;plot of chunk mapear_cor&#34; alt=&#34;plot of chunk mapear_cor&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Aqui, o número de cilindros, &lt;code&gt;cyl&lt;/code&gt;, é representado pela tonalidade da cor azul.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nota&lt;/strong&gt;: por &lt;em&gt;default&lt;/em&gt;, a legenda é insirida no gráfico automaticamente.&lt;/p&gt;

&lt;p&gt;Também podemos mapear o tamanho dos pontos à uma variável de interesse:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars) +
  geom_point(mapping = aes(x = disp, y = mpg, colour = cyl, size = wt))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//mapear_tamanaho-1.png&#34; title=&#34;plot of chunk mapear_tamanaho&#34; alt=&#34;plot of chunk mapear_tamanaho&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exercício&lt;/strong&gt;: pesquisar mais aspectos que podem ser alterados no gráfico de dispersão. &lt;a href=&#34;http://ggplot2.tidyverse.org/articles/ggplot2-specs.html&#34;&gt;Essa&lt;/a&gt; é uma
boa referência.&lt;/p&gt;

&lt;h2 id=&#34;geoms&#34;&gt;Geoms&lt;/h2&gt;

&lt;p&gt;Os &lt;em&gt;geoms&lt;/em&gt; definem qual forma geométrica será utilizada para a visualização dos
dados no gráfico. Como já vimos, a função &lt;code&gt;geom_point()&lt;/code&gt; gera gráficos de dispersão
transformando pares (x,y) em pontos. Veja a seguir outros &lt;em&gt;geoms&lt;/em&gt; bastante utilizados:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;geom_line&lt;/code&gt;: para linhas definidas por pares (x,y)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_abline&lt;/code&gt;: para retas definidas por um intercepto e uma inclinação&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_hline&lt;/code&gt;: para retas horizontais&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_boxplot&lt;/code&gt;: para boxplots&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_histogram&lt;/code&gt;: para histogramas&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_density&lt;/code&gt;: para densidades&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_area&lt;/code&gt;: para áreas&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_bar&lt;/code&gt;: para barras&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Veja a seguir como é fácil gerar diversos gráficos diferentes utilizando a mesma estrutura do gráfico de dispersão acima:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars) + 
  geom_boxplot(aes(x = as.factor(cyl), y = mpg))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-7-1.png&#34; title=&#34;plot of chunk unnamed-chunk-7&#34; alt=&#34;plot of chunk unnamed-chunk-7&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; que para fazer um boxplot para cada grupo, precisamos passar para o aspecto
x do gráfico uma variável do tipo &lt;code&gt;factor&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars) + 
  geom_histogram(aes(x = mpg))
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-8-1.png&#34; title=&#34;plot of chunk unnamed-chunk-8&#34; alt=&#34;plot of chunk unnamed-chunk-8&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars) + 
  geom_bar(aes(x = as.factor(cyl)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-9-1.png&#34; title=&#34;plot of chunk unnamed-chunk-9&#34; alt=&#34;plot of chunk unnamed-chunk-9&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
Um padrão para os gráficos
&lt;/p&gt;
&lt;p&gt;
Você deve ter percebido que para fazer um gráfico usando `ggplot2` e a gramática
dos gráficos, existe um padrão:

```
ggplot(data = &lt;DATA&gt;) + 
  &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;))
```

Para fazer um gráfico, basta substituir o que está entre `&lt;` com um banco de dados,
uma função geométrica e uma coleção de *mapas estéticos*. Isso será muito útil quando você for fazer o seu próprio gráfico.
&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;exercícios&#34;&gt;Exercícios&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Rode &lt;code&gt;ggplot(data = mtcars)&lt;/code&gt;. O que você vê?&lt;/li&gt;
&lt;li&gt;Quantas linhas existem no &lt;code&gt;mtcars&lt;/code&gt;. Quantas colunas? &lt;strong&gt;Dica&lt;/strong&gt;: use a função &lt;code&gt;nrows&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;O que a variável &lt;code&gt;qsec&lt;/code&gt; descreve. Leia o help do &lt;code&gt;mtcars&lt;/code&gt; para encontrar.&lt;/li&gt;
&lt;li&gt;Faça um gráfico de dispersão de &lt;code&gt;mpg&lt;/code&gt; por &lt;code&gt;qsec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;O que acontece se você fizer um gráfico de dispersão de &lt;code&gt;vs&lt;/code&gt; por &lt;code&gt;mpg&lt;/code&gt;? Porque o
gráfico não é útil?&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;combinando-gráficos&#34;&gt;Combinando gráficos&lt;/h2&gt;

&lt;p&gt;Considere os 2 gráficos a seguir.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# esquerda
ggplot(mtcars) + 
  geom_point(aes(y = mpg, x = disp))
# direita
ggplot(mtcars) + 
  geom_smooth(aes(y = mpg, x = disp))
## `geom_smooth()` using method = &#39;loess&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//duplochunk-1.png&#34; title=&#34;plot of chunk duplochunk&#34; alt=&#34;plot of chunk duplochunk&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;img src=&#34;figures//duplochunk-2.png&#34; title=&#34;plot of chunk duplochunk&#34; alt=&#34;plot of chunk duplochunk&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Os gráficos são similares e completaam-se. O da esquerda, mostra como os pontos estão distribuídos. Ele mostra uma tendência de aumento do consumo de combustível de acordo
com as cilindradas. Já o gráfico da direita, resume essa relação. Simplificando-a para uma linha de tendência com alguma margem de confiança.&lt;/p&gt;

&lt;p&gt;Esses dois gráficos se completam, e ficam bons juntos. Com o &lt;code&gt;ggplot2&lt;/code&gt; é muito fácil
sobrepor os dois gráficos, pois ele é pensado para que cada gráfico seja feito com
uma combinação de camadas. Veja o código abaixo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars) + 
  geom_point(aes(y = mpg, x = disp)) +
  geom_smooth(aes(y = mpg, x = disp))
## `geom_smooth()` using method = &#39;loess&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-10-1.png&#34; title=&#34;plot of chunk unnamed-chunk-10&#34; alt=&#34;plot of chunk unnamed-chunk-10&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Desta forma, sobrepusemos os pontos e a linha de suavização. No entanto, duplicamos alguns trechos no nosso código, o que geralmente não é bom. Imagine se você precisar
mudar a variável do eixo &lt;code&gt;y&lt;/code&gt;, você precisará trocar o nome da variável em mais de um
lugar do código. Para resolver isso, você pode definir o &lt;em&gt;mapping&lt;/em&gt; apenas uma vez
dentro da declaração do gráfico, conforme o código a seguir.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars, aes(y = mpg, x = disp)) + 
  geom_point() +
  geom_smooth()
## `geom_smooth()` using method = &#39;loess&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-11-1.png&#34; title=&#34;plot of chunk unnamed-chunk-11&#34; alt=&#34;plot of chunk unnamed-chunk-11&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Veja que isso gera o mesmo gráfico!&lt;/p&gt;

&lt;p&gt;Veja que mesmo com dois &lt;code&gt;geom&lt;/code&gt;&amp;rsquo;s, o &lt;code&gt;ggplot&lt;/code&gt; segue a mesma regra para mapear as
variáveis para as &lt;code&gt;aesthetics&lt;/code&gt;. Por exemplo, se você mapear uma variável para
a cor, você obterá o seguinte gráfico.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars, aes(y = mpg, x = disp, colour = as.factor(cyl))) + 
  geom_point() +
  geom_smooth(method = &amp;quot;lm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-12-1.png&#34; title=&#34;plot of chunk unnamed-chunk-12&#34; alt=&#34;plot of chunk unnamed-chunk-12&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O &lt;code&gt;ggplot2&lt;/code&gt; agora desenhou uma reta para cada um dos grupos de pontos e coloriu
cada grupo de pontos de uma cor diferente. Em alguns casos, você pode querer mapear
a cor em apenas uma das camadas do gráfico. Isso pode ser feito da seguinte forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars, aes(y = mpg, x = disp)) + 
  geom_point(aes(colour = as.factor(cyl))) +
  geom_smooth(method = &amp;quot;lm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-13-1.png&#34; title=&#34;plot of chunk unnamed-chunk-13&#34; alt=&#34;plot of chunk unnamed-chunk-13&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note que agora, cada grupo de pontos tem uma cor mas a reta é única, para todos os pontos.&lt;/p&gt;

&lt;h2 id=&#34;alterando-os-padrões-do-gráfico&#34;&gt;Alterando os padrões do gráfico&lt;/h2&gt;

&lt;p&gt;Até agora, sempre &lt;em&gt;mapeamos&lt;/em&gt; uma forma estética à uma variável. Muitas vezes
queremos apenas modificar esta forma estética sem mapeá-la a outra variável.
Por exemplo, no gráfico a seguir, modificamos a cor de todos os pontos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars, aes(y = mpg, x = disp)) + 
  geom_point(colour = &amp;quot;red&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-14-1.png&#34; title=&#34;plot of chunk unnamed-chunk-14&#34; alt=&#34;plot of chunk unnamed-chunk-14&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A principal diferença aqui é que especificamos o argumento &lt;code&gt;colour&lt;/code&gt; fora da função
&lt;code&gt;aes&lt;/code&gt; como estávamos fazendo antes. Dessa forma podemos controlar todos os parâmetros
de cada forma geométrica.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars, aes(y = mpg, x = disp)) + 
  geom_point(colour = &amp;quot;red&amp;quot;, size = 2, shape = 3, alpha = 0.5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-15-1.png&#34; title=&#34;plot of chunk unnamed-chunk-15&#34; alt=&#34;plot of chunk unnamed-chunk-15&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;facets&#34;&gt;Facets&lt;/h2&gt;

&lt;p&gt;Uma funcionalidade muito útil do &lt;code&gt;ggplot2&lt;/code&gt; é a possibilidade de usar &lt;code&gt;facets&lt;/code&gt;.
Isso auxilia na visualização de diferentes subconjuntos dos dados em gráficos
separados, permitindo a visualização de comportamentos diferentes dependendo
do grupo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(mtcars, aes(y = mpg, x = disp)) + 
  geom_point() +
  geom_smooth(method = &amp;quot;lm&amp;quot;) + 
  facet_wrap(~am)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-16-1.png&#34; title=&#34;plot of chunk unnamed-chunk-16&#34; alt=&#34;plot of chunk unnamed-chunk-16&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;No gráfico acima, rapidamente conseguimos visualizar que se o carro não é automático o consumo de combustível é muito menor do que quando o carro é automático. Também conseguimos ver que a inclinação das retas é bem diferente dependendo do carro ser
automático/manual.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;O que tem de errado no código abaixo? Por que os pontos não ficaram azuis?&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = &amp;quot;blue&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-19-1.png&#34; title=&#34;plot of chunk unnamed-chunk-19&#34; alt=&#34;plot of chunk unnamed-chunk-19&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Mapeie uma variável contínua para uma cor, tamanho e forma. Como essas formas
estéticas se comportam diferente para variáveis categóricas vs. contínuas?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Começando de um simples boxplot feito no &lt;code&gt;ggplot2&lt;/code&gt; vamos fazer diversas alterações nas legendas. O gráfico inicial é construido da seguinte forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
# boxplot simples
bp &amp;lt;- ggplot(data=PlantGrowth, aes(x=group, y=weight, fill=group)) + geom_boxplot()
bp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-21-1.png&#34; title=&#34;plot of chunk unnamed-chunk-21&#34; alt=&#34;plot of chunk unnamed-chunk-21&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;removendo-totalmente-a-legenda&#34;&gt;Removendo totalmente a legenda&lt;/h2&gt;

&lt;p&gt;Existem diversas maneiras para remover a legenda de um gráfico no &lt;code&gt;ggplot2&lt;/code&gt;. A forma mais simples é usar &lt;code&gt;guides(fill = FALSE)&lt;/code&gt; com &lt;code&gt;fill&lt;/code&gt; sendo o atributo gráfico do qual você deseja remover a legenda.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# aqui definimos fill = FALSE, porque é o atributo do gráfico que relacionamos 
# a alguma variável.
bp + guides(fill = FALSE)

# também é possível remover a legenda por meio da escala de cores
# aqui também usamos o scale_fill_discrete, porque associamos fill
# a uma variável anteriormente.
bp + scale_fill_discrete(guide = F)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-22-1.png&#34; title=&#34;plot of chunk unnamed-chunk-22&#34; alt=&#34;plot of chunk unnamed-chunk-22&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;img src=&#34;figures//unnamed-chunk-22-2.png&#34; title=&#34;plot of chunk unnamed-chunk-22&#34; alt=&#34;plot of chunk unnamed-chunk-22&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# o comando a seguir remove todas as legendas, não importa o atributo que ela
# esteja representando.
bp + theme(legend.position=&amp;quot;none&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-23-1.png&#34; title=&#34;plot of chunk unnamed-chunk-23&#34; alt=&#34;plot of chunk unnamed-chunk-23&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;alterando-a-ordem-dos-itens&#34;&gt;Alterando a ordem dos itens&lt;/h2&gt;

&lt;p&gt;Para alterar a ordem dos itens na legenda do gráfico no &lt;code&gt;ggplot2&lt;/code&gt;, usamos o comando da escala de cores.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bp + scale_fill_discrete(breaks=c(&amp;quot;trt1&amp;quot;,&amp;quot;ctrl&amp;quot;,&amp;quot;trt2&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-24-1.png&#34; title=&#34;plot of chunk unnamed-chunk-24&#34; alt=&#34;plot of chunk unnamed-chunk-24&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-24-2.png&#34; title=&#34;plot of chunk unnamed-chunk-24&#34; alt=&#34;plot of chunk unnamed-chunk-24&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Dependendo de os aspectos gráficos (Ex: cores, formatos, preenchimentos) foram especificados você pode precisar usar alguma das seguintes funções: &lt;code&gt;scale_fill_manual&lt;/code&gt;, &lt;code&gt;scale_colour_hue&lt;/code&gt;, &lt;code&gt;scale_colour_manual&lt;/code&gt;, &lt;code&gt;scale_shape_discrete&lt;/code&gt;, &lt;code&gt;scale_linetype_discrete&lt;/code&gt; , e assim por diante.&lt;/p&gt;

&lt;p&gt;Você pode também querer inverter a ordem dos itens da legenda. Isso pode ser feito de uma das seguintes maneiras.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bp + guides(fill = guide_legend(reverse=TRUE))
bp + scale_fill_discrete(guide = guide_legend(reverse=TRUE))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-25-1.png&#34; title=&#34;plot of chunk unnamed-chunk-25&#34; alt=&#34;plot of chunk unnamed-chunk-25&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;img src=&#34;figures//unnamed-chunk-25-2.png&#34; title=&#34;plot of chunk unnamed-chunk-25&#34; alt=&#34;plot of chunk unnamed-chunk-25&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;removendo-os-títulos-da-legenda&#34;&gt;Removendo os títulos da legenda&lt;/h2&gt;

&lt;p&gt;Algumas vezes é necessário remover o título das legendas do gráfico feito no &lt;code&gt;ggplot2&lt;/code&gt;.
Veja a seguir algumas maneiras:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Remove o título apenas da legenda do preenchimento (fill)
bp + guides(fill=guide_legend(title=NULL))

# Remove o título de todas as legendas
bp + theme(legend.title=element_blank())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-26-1.png&#34; title=&#34;plot of chunk unnamed-chunk-26&#34; alt=&#34;plot of chunk unnamed-chunk-26&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;img src=&#34;figures//unnamed-chunk-26-2.png&#34; title=&#34;plot of chunk unnamed-chunk-26&#34; alt=&#34;plot of chunk unnamed-chunk-26&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;modificando-texto-cores-e-rótulos&#34;&gt;Modificando texto, cores e rótulos&lt;/h2&gt;

&lt;p&gt;Para modificar os textos e rótulos das legendas existem duas formas. Uma delas é modificar o &lt;code&gt;data.frame&lt;/code&gt; de forma com que os fatores tenham o mesmo nome que você deseja na legenda. Outra forma é usando as funções de &lt;code&gt;scale&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Veja algumas modificações que podem ser feitas por meio das funções de &lt;code&gt;scale&lt;/code&gt;. Como a variável &lt;code&gt;group&lt;/code&gt; está associada ao atributo &lt;code&gt;fill&lt;/code&gt;, usamos as funções &lt;code&gt;scale_fill_xxx&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# usamos scale_fill_discrete porque não queremos alterar as cores padrão,
# mas queremos que cada fator esteja associado a uma cor de tom diferente.
# mudamos aqui os rótulos e o título da legenda.
bp + scale_fill_discrete(name=&amp;quot;Experimental\nCondition&amp;quot;,
                         breaks=c(&amp;quot;ctrl&amp;quot;, &amp;quot;trt1&amp;quot;, &amp;quot;trt2&amp;quot;),
                         labels=c(&amp;quot;Control&amp;quot;, &amp;quot;Treatment 1&amp;quot;, &amp;quot;Treatment 2&amp;quot;))


# usamos scale_fill_manual porque queremos alterar as cores padrão.
# aqui escolhemos as cores da escala hexadecimal.
bp + scale_fill_manual(values=c(&amp;quot;#999999&amp;quot;, &amp;quot;#E69F00&amp;quot;, &amp;quot;#56B4E9&amp;quot;), 
                       name=&amp;quot;Experimental\nCondition&amp;quot;,
                       breaks=c(&amp;quot;ctrl&amp;quot;, &amp;quot;trt1&amp;quot;, &amp;quot;trt2&amp;quot;),
                       labels=c(&amp;quot;Control&amp;quot;, &amp;quot;Treatment 1&amp;quot;, &amp;quot;Treatment 2&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-27-1.png&#34; title=&#34;plot of chunk unnamed-chunk-27&#34; alt=&#34;plot of chunk unnamed-chunk-27&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;img src=&#34;figures//unnamed-chunk-27-2.png&#34; title=&#34;plot of chunk unnamed-chunk-27&#34; alt=&#34;plot of chunk unnamed-chunk-27&#34; width=&#34;50%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Veja que isso não aletrou o eixo X do gráfico.&lt;/p&gt;

&lt;h2 id=&#34;modificando-a-aparência-da-legenda&#34;&gt;Modificando a aparência da legenda&lt;/h2&gt;

&lt;p&gt;Existem inúmeras modificações que podem ser realizadas na aparência da legenda. Todas elas estão relacionadas à modificação do &lt;code&gt;element_text&lt;/code&gt;. Veja neste &lt;a href=&#34;http://docs.ggplot2.org/0.9.2.1/element_text.html&#34;&gt;link&lt;/a&gt; todos os atributos que podem ser modificados.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Mudando a aparência do título
bp + theme(legend.title = element_text(colour=&amp;quot;blue&amp;quot;, size=16, face=&amp;quot;bold&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-28-1.png&#34; title=&#34;plot of chunk unnamed-chunk-28&#34; alt=&#34;plot of chunk unnamed-chunk-28&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Mudando a aparência dos rótulos
bp + theme(legend.text = element_text(colour=&amp;quot;blue&amp;quot;, size = 16, face = &amp;quot;bold&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-29-1.png&#34; title=&#34;plot of chunk unnamed-chunk-29&#34; alt=&#34;plot of chunk unnamed-chunk-29&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;modificando-a-posição-da-legenda&#34;&gt;Modificando a posição da legenda&lt;/h2&gt;

&lt;p&gt;É possível controlar a posição da legenda facilmente escolhendo uma das posições (left/right/top/bottom).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bp + theme(legend.position=&amp;quot;top&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-30-1.png&#34; title=&#34;plot of chunk unnamed-chunk-30&#34; alt=&#34;plot of chunk unnamed-chunk-30&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Também é possível controlar a posição da legenda de forma precisa usando o comando.
Desta forma ela será posicionada dentro do gráfico com o ponto central sendo o valor do argumento &lt;code&gt;legend.position&lt;/code&gt;. Esses valores são definidos de forma que o ponto (0,0) seja o canto inferior esquerdo e (1,1) seja o canto superior direito.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;bp + theme(legend.position=c(.5, .5))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-31-1.png&#34; title=&#34;plot of chunk unnamed-chunk-31&#34; alt=&#34;plot of chunk unnamed-chunk-31&#34; width=&#34;40%&#34; height=&#34;40%&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Curso-R</title>
      <link>/</link>
      <pubDate>Wed, 09 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;p&gt;O curso-r ensinará como usar o R para auxiliar o aluno na execução de tarefas corriqueiras de forma eficiente e concisa. O aluno aprenderá a:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Carregar&lt;/strong&gt;: Carregar o banco de dados para dentro do R&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Arrumar&lt;/strong&gt;: Deixar os dados na melhor estrutura para a análise&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transformar&lt;/strong&gt;: Agregar, criar novas variáveis, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Visualizar&lt;/strong&gt;: Criar gráficos e visualizações&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Modelar&lt;/strong&gt;: Ajustar modelos que ajudam na interpretação dos dados&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O curso será baseado no &lt;a href=&#34;http://r4ds.had.co.nz/&#34;&gt;&lt;em&gt;R for Data Science&lt;/em&gt;&lt;/a&gt; que por sua vez é baseado no &lt;a href=&#34;http://tidyverse.org/&#34;&gt;&lt;code&gt;tidyverse&lt;/code&gt;&lt;/a&gt;, &lt;em&gt;universo arrumado&lt;/em&gt;, um conjunto de pacotes que dividem uma mesma filosofia e foram feitos para serem utilizados conjuntamente.&lt;/p&gt;
&lt;div id=&#34;publico-alvo&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Público Alvo&lt;/h2&gt;
&lt;p&gt;O curso-r é destinado a:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Estudantes de graduação em estatística que desejam ganhar tempo nos trabalhos da faculdade e entrar no mercado de trabalho com bons diferenciais.&lt;/li&gt;
&lt;li&gt;Profissionais do mercado de trabalho que desejam inserir o R mo fluxo de atividades do setor/empresa.&lt;/li&gt;
&lt;li&gt;Acadêmicos com interesse em tornar suas análises e códigos mais legíveis, reprodutíveis, eficientes e organizados.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;softwares&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Softwares&lt;/h2&gt;
&lt;p&gt;O curso será realizado em um laboratório, onde os softwares já estarão instalados mas, para fazer os exercícios fora da aula você precisará instalar os seguintes softwares/pacotes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R: Instale pelo site do &lt;a href=&#34;https://cloud.r-project.org/&#34;&gt;CRAN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RStudio: Faça o download &lt;a href=&#34;https://www.rstudio.com/products/rstudio/download3/&#34;&gt;aqui&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tidyverse&lt;/code&gt;: No console do R digite: &lt;code&gt;install.packages(&amp;quot;tidyverse&amp;quot;)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;pre-requisitos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Pré-requisitos&lt;/h2&gt;
&lt;p&gt;Para melhor aproveitamento do curso é importante o aluno ter alguns conhecimentos sobre &lt;strong&gt;Lógica de programação&lt;/strong&gt;. Não se preocupe, se você já fez qualquer curso de programação na vida, já será o suficiente.&lt;/p&gt;
&lt;p&gt;Se o aluno não for familiarizado com R, recomendamos abrir o RStudio e tentar rodar e entender os comandos &lt;a href=&#34;https://curso-r.github.io/verao2017/r-como-calculadora/&#34;&gt;desta página&lt;/a&gt;. Tente fazer os &lt;a href=&#34;https://curso-r.github.io/verao2017/r-como-calculadora/#exercicios&#34;&gt;exercícios&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Durante o curso iremos usar bastante o &lt;a href=&#34;https://github.com/&#34;&gt;Github&lt;/a&gt;, portanto criar uma conta será fundamental.&lt;/p&gt;
&lt;p&gt;Tente se familiarizar com &lt;a href=&#34;http://rmarkdown.rstudio.com/lesson-1.html&#34;&gt;RMarkdown&lt;/a&gt;. O curso utilizará este formato de arquivos extensivamente.&lt;/p&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD




/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/test/</guid>
      <description>/BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;introducao-stringr&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introdução: Stringr&lt;/h1&gt;
&lt;p&gt;Variáveis do tipo texto são muito comuns nos bancos de dados e geralmente são colunas que dão bastante trabalho para serem manipuladas. É muito comun encontrar bancos de dados em que os textos de uma coluna não estão padronizados, por exemplo uma coluna &lt;code&gt;Estado&lt;/code&gt; em que são encontrados “SP”, “sp”, “Sao Paulo”, “São Paulo”, etc todas as variações indicando o mesmo estado.&lt;/p&gt;
&lt;p&gt;Para manipular esses textos o R possui diversas funções para manipular textos, no entanto, as funções do &lt;code&gt;base&lt;/code&gt; não possuem um interface consistente e parece que cada uma tem a sua forma de passar os parâmetros, dificultando o processo durante a análise.&lt;/p&gt;
&lt;p&gt;Por isso, é recomendado usar o pacote &lt;code&gt;stringr&lt;/code&gt; que possui a sintaxe consistente permitindo que o usuário realize qualquer manipulação com textos com maior facilidade.&lt;/p&gt;
&lt;div id=&#34;vantagens-do-stringr-em-relacao-ao-base&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Vantagens do stringr em relação ao base&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sintaxe unificada, o que auxilia na memorização e leitura do código.&lt;/li&gt;
&lt;li&gt;Todas as funções são vetorizadas.&lt;/li&gt;
&lt;li&gt;Construído sobre a &lt;a href=&#34;http://site.icu-project.org/&#34;&gt;biblioteca ICU&lt;/a&gt;, implementada em &lt;code&gt;C&lt;/code&gt; e &lt;code&gt;C++&lt;/code&gt;, apresentando resultados rápidos e confiáveis.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;regras-basicas-do-pacote&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Regras básicas do pacote&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;As funções de manipulação de texto começam com &lt;code&gt;str_&lt;/code&gt;. Caso esqueça o nome de uma função, basta digitar &lt;code&gt;stringr::str_&lt;/code&gt; e apertar &lt;code&gt;TAB&lt;/code&gt; para ver quais são as opções.&lt;/li&gt;
&lt;li&gt;O primeiro argumento da função é sempre uma &lt;code&gt;string&lt;/code&gt; ou um vetor de &lt;code&gt;strings&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;curiosidade&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Curiosidade&lt;/h2&gt;
&lt;p&gt;Inicialmente, o &lt;code&gt;stringr&lt;/code&gt; era um &lt;em&gt;wrapper&lt;/em&gt; de funções do &lt;code&gt;base&lt;/code&gt;. Depois disso, surgiu um novo pacote &lt;code&gt;stringi&lt;/code&gt;, com sintaxe similar ao &lt;code&gt;stringr&lt;/code&gt;, mas funcionando como &lt;em&gt;wrapper&lt;/em&gt; da biblioteca ICU. No entanto, Wickham gostou tanto do pacote &lt;code&gt;stringi&lt;/code&gt; que decidiu reescrever o &lt;code&gt;stringr&lt;/code&gt; como um &lt;em&gt;wrapper&lt;/em&gt; do &lt;code&gt;stringi&lt;/code&gt;. Veja &lt;a href=&#34;https://github.com/tidyverse/stringr/blob/master/NEWS.md&#34;&gt;essa página&lt;/a&gt; para detalhes. #stringr: Básico #### str_to_upper, str_to_lower, str_to_title #str_to_title(s)&lt;/p&gt;
&lt;p&gt;Todas as funções do &lt;code&gt;stringr&lt;/code&gt; começam com o prefixo &lt;code&gt;str&lt;/code&gt;, isso ajuda na hora de encontrar a função que você está procurando. No Rstudio, basta digitar &lt;code&gt;str_&lt;/code&gt; e apertar tab que você verá algo parecido com a imagem a baixo. Você pode ir descendo com as setas do teclado e ver o que cada função faz até encontrar a função que estava procurando.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;./home/travis/build/azeloc/pu.test/figure/str_tab.png&#34; alt=&#34;str_tab&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;str_tab&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Nesta sessão vamos utilizar as funções mais simples do &lt;code&gt;stringr&lt;/code&gt;, depois vamos ensinar um pouco de Regex e em seguida veremos as funções mais avançadas do pacote.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;funcoes-basicas&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Funções básicas&lt;/h2&gt;
&lt;div id=&#34;str_length&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_length&lt;/h3&gt;
&lt;p&gt;A função mais simples do &lt;code&gt;stringr&lt;/code&gt; é a função &lt;code&gt;str_length&lt;/code&gt;. Esta função recebe apenas uma string como argumento e retorna o número de caracteres. Por exemplo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(stringr)
str_length(&amp;quot;olá&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;length(&amp;quot;olá&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Veja &lt;code&gt;str_length&lt;/code&gt; é diferente de &lt;code&gt;length&lt;/code&gt;. O primeiro retorna o número de caracteres e o segundo retorna o comprimento do objeto. Isso fica mais claro no seguinte exemplo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s &amp;lt;- c(&amp;quot;olá mundo&amp;quot;, &amp;quot;olá universo&amp;quot;)
str_length(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  9 12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;length(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora o &lt;code&gt;str_length&lt;/code&gt; retornou um vetor com o número de caracteres de cada elemento do vetor &lt;code&gt;s&lt;/code&gt;, e o &lt;code&gt;length&lt;/code&gt; retornou o comprimento do vetor &lt;code&gt;s&lt;/code&gt;. Note que espaço é considerado como um caractere.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;str_trim&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_trim&lt;/h3&gt;
&lt;p&gt;É muito comum encontrar textos que vêm com espaços a mais, principalmente de dados provenientes de formulários em que cada usuário escreve da forma que prefere.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;string &amp;lt;- &amp;#39;\nessa      string é muito suja       \n&amp;#39;
str_trim(string)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;essa      string é muito suja&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A função &lt;code&gt;str_trim&lt;/code&gt; ajuda removendo os espaços excedetes antes e depois da string.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;str_sub&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_sub&lt;/h3&gt;
&lt;p&gt;As vezes você precisa obter alguma parte fixa de uma string. Por exemplo, as vezes você encontra variáveis com valores da forma:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s &amp;lt;- c(&amp;quot;01-Feminino&amp;quot;, &amp;quot;02-Masculino&amp;quot;, &amp;quot;03-Indefinido&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Você pode querer manipular essa string para retirar obter apenas a parte final da string. Neste caso pode usar a função &lt;code&gt;str_sub&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_sub(s, start = 4) # pegar do quarto até o último caractere&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Feminino&amp;quot;   &amp;quot;Masculino&amp;quot;  &amp;quot;Indefinido&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;É possível obter também apenas os números&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_sub(s, end = 2) # pegar apenas os dois primeiros caracteres&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;01&amp;quot; &amp;quot;02&amp;quot; &amp;quot;03&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Em outros casos você precisa obter os últimos 2 caracteres.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s &amp;lt;- c(&amp;quot;Feminino-01&amp;quot;, &amp;quot;Masculino-02&amp;quot;, &amp;quot;Indefinido-03&amp;quot;)
str_sub(s, end = -4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Feminino&amp;quot;   &amp;quot;Masculino&amp;quot;  &amp;quot;Indefinido&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_sub(s, start = -2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;01&amp;quot; &amp;quot;02&amp;quot; &amp;quot;03&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;É possível também usar os argumentos &lt;code&gt;start&lt;/code&gt; e &lt;code&gt;end&lt;/code&gt; conjuntamente.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s &amp;lt;- c(&amp;quot;__SP__&amp;quot;, &amp;quot;__MG__&amp;quot;, &amp;quot;__RJ__&amp;quot;)
str_sub(s, 3, 4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;SP&amp;quot; &amp;quot;MG&amp;quot; &amp;quot;RJ&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;str_to_upper-str_to_lower-str_to_title&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_to_upper, str_to_lower, str_to_title&lt;/h3&gt;
&lt;p&gt;Essas funções servem para modificar a caixa das letras. Por exemplo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s &amp;lt;- &amp;quot;Olá, tudo bem?&amp;quot;
str_to_lower(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;olá, tudo bem?&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_to_upper(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;OLÁ, TUDO BEM?&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_to_title(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Olá, Tudo Bem?&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Essas são as funções mais simples do pacote &lt;code&gt;stringr&lt;/code&gt; e mão exigem nenhum conhecimento de regex. Note que nenhuma delas possui o parâmetro &lt;code&gt;pattern&lt;/code&gt;, você verá como especificar esse parâmetros nas próximas sessões.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;regex&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Regex&lt;/h1&gt;
&lt;p&gt;Trabalhar com textos exige um certo conhecimento de expressões regulares (&lt;em&gt;regex&lt;/em&gt;). &lt;a href=&#34;https://pt.wikipedia.org/wiki/Express%C3%A3o_regular&#34;&gt;Expressões regulares&lt;/a&gt; permitem identificar conjuntos de caracters, palavras, e outros padrões por meio de uma sintaxe concisa.&lt;/p&gt;
&lt;p&gt;O &lt;code&gt;stringr&lt;/code&gt; utiliza regex da forma descrita &lt;a href=&#34;http://www.gagolewski.com/software/stringi/manual/?manpage=stringi-search-regex&#34;&gt;neste documento&lt;/a&gt;. A própria &lt;a href=&#34;https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html&#34;&gt;definição&lt;/a&gt; de regex do R é um ótimo manual.&lt;/p&gt;
&lt;div id=&#34;expressoes-regulares&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Expressões regulares&lt;/h2&gt;
&lt;p&gt;Expressão regular ou &lt;em&gt;regex&lt;/em&gt; é uma sequência concisa de caracteres que representa várias strings. Entender o básico de expressões regulares é indispensável para trabalhar com textos.&lt;/p&gt;
&lt;p&gt;Vamos estudar expressões regulares através de exemplos e com a função &lt;code&gt;str_detect()&lt;/code&gt;. Essa função retorna &lt;code&gt;TRUE&lt;/code&gt; se uma string atende à uma expressão regular e &lt;code&gt;FALSE&lt;/code&gt; em caso contrário.&lt;/p&gt;
&lt;p&gt;Por exemplo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(stringr)
str_detect(&amp;quot;sao paulo&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_detect(&amp;quot;sao paulo sp&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A regex/pattern “paulo&lt;span class=&#34;math inline&#34;&gt;\(&amp;quot; indica que o texto deve ser terminado em &amp;quot;paulo&amp;quot;. Existem diversos de caracteres auxiliares que vão auxiliar na manipulação dos textos, assim como o &amp;quot;\)&lt;/span&gt;” neste caso. É importante notar que sempre que você estiver passando algum valor para o argumento &lt;code&gt;pattern&lt;/code&gt; de qualquer função do &lt;code&gt;stringr&lt;/code&gt; ele o entenderá como uma regex.&lt;/p&gt;
&lt;p&gt;A tabela abaixo mostra a aplicação de seis &lt;code&gt;regex&lt;/code&gt; a seis strings distintas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;testes &amp;lt;- c(&amp;#39;ban&amp;#39;, &amp;#39;banana&amp;#39;, &amp;#39;abandonado&amp;#39;, &amp;#39;pranab anderson&amp;#39;, &amp;#39;BANANA&amp;#39;, 
            &amp;#39;ele levou ban&amp;#39;)

expressoes &amp;lt;- list(
  &amp;#39;ban&amp;#39;, # reconhece tudo que tenha &amp;quot;ban&amp;quot;, mas não ignora case
  &amp;#39;BAN&amp;#39;, # reconhece tudo que tenha &amp;quot;BAN&amp;quot;, mas não ignora case
  regex(&amp;#39;ban&amp;#39;, ignore_case = TRUE), # reconhece tudo que tenha &amp;quot;ban&amp;quot;, ignorando case
  &amp;#39;ban$&amp;#39;, # reconhece apenas o que termina exatamente em &amp;quot;ban&amp;quot;
  &amp;#39;^ban&amp;#39;, # reconhece apenas o que começa exatamente com &amp;quot;ban&amp;quot;
  &amp;#39;b ?an&amp;#39; # reconhece tudo que tenha &amp;quot;ban&amp;quot;, com ou sem espaço entre o &amp;quot;b&amp;quot; e o &amp;quot;a&amp;quot;
)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;quantificadores&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Quantificadores&lt;/h2&gt;
&lt;p&gt;Os caracteres &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; e &lt;code&gt;{x,y}&lt;/code&gt; indicam quantas vezes um padrão se repete:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ey+&lt;/code&gt; significa &lt;code&gt;e&lt;/code&gt; e depois &lt;code&gt;y&lt;/code&gt; “&lt;strong&gt;uma vez&lt;/strong&gt; ou mais”. Por exemplo, reconhece &lt;code&gt;hey&lt;/code&gt;, &lt;code&gt;heyy&lt;/code&gt;, &lt;code&gt;a eyyy&lt;/code&gt;, mas não reconhece &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; nem &lt;code&gt;yy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ey*&lt;/code&gt; significa “&lt;strong&gt;zero vezes&lt;/strong&gt; ou mais”. Por exemplo, reconhece &lt;code&gt;hey&lt;/code&gt;, &lt;code&gt;heyy&lt;/code&gt;, &lt;code&gt;a eyyy&lt;/code&gt; e &lt;code&gt;e&lt;/code&gt;, mas não reconhece &lt;code&gt;y&lt;/code&gt; nem &lt;code&gt;yy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ey{3}&lt;/code&gt; significa “exatamente três vezes”. Por exemplo, reconhece &lt;code&gt;eyyy&lt;/code&gt; e &lt;code&gt;eyyyy&lt;/code&gt;, mas não reconhece &lt;code&gt;eyy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ey{1,3}&lt;/code&gt; significa “entre uma e três vezes”.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para aplicar um quantificador a um conjunto de caracteres, use parênteses. Por exemplo, &lt;code&gt;(ey )+&lt;/code&gt; reconhece &lt;code&gt;ey ey&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conjuntos&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conjuntos&lt;/h2&gt;
&lt;p&gt;Colocando caracteres dentro de &lt;code&gt;[]&lt;/code&gt;, reconhecemos quaisquer caracteres desse conjunto. Alguns exemplos práticos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[Cc]asa&lt;/code&gt; para reconhecer “casa” em maiúsculo ou minúsculo.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9]&lt;/code&gt; para reconhecer somente números. O mesmo vale para letras &lt;code&gt;[a-z]&lt;/code&gt;, &lt;code&gt;[A-Z]&lt;/code&gt;, &lt;code&gt;[a-zA-Z]&lt;/code&gt; etc.&lt;/li&gt;
&lt;li&gt;O símbolo &lt;code&gt;^&lt;/code&gt; dentro do colchete significa negação. Por exemplo, &lt;code&gt;[^0-9]&lt;/code&gt; significa pegar tudo o que não é número.&lt;/li&gt;
&lt;li&gt;O símbolo &lt;code&gt;.&lt;/code&gt; fora do colchete indica “qualquer caractere”, mas dentro do colchete é apenas ponto.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;[[:space:]]+&lt;/code&gt; para reconhecer espaços e &lt;code&gt;[[:punct:]]+&lt;/code&gt; para reconhecer pontuações.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;miscelanea&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Miscelânea&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;abjutils::rm_accent()&lt;/code&gt; para retirar os acentos de um texto.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;|&lt;/code&gt; para opções, por exemplo &lt;code&gt;desfavor|desprov&lt;/code&gt; reconhece tanto “desfavorável” quanto “desprovido”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\n&lt;/code&gt; pula linha, &lt;code&gt;\f&lt;/code&gt; é final da página, &lt;code&gt;\t&lt;/code&gt; é tab. Use &lt;code&gt;\&lt;/code&gt; para transformar caracteres especiais em literais.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tolower()&lt;/code&gt; e &lt;code&gt;toupper()&lt;/code&gt; para mudar o case de uma string.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A lista de possibilidades com expressões regulares é extensa. Um bom lugar para testar o funcionamento de expressões regulares é o &lt;a href=&#34;https://regex101.com/&#34;&gt;regex101&lt;/a&gt;. #stringr: Avançado&lt;/p&gt;
&lt;p&gt;Agora que já vimos as funções básicas do &lt;code&gt;stringr&lt;/code&gt;, e aprendemos um pouco de regex, vamos às funções mais avançadas. Basicmante, essas funções buscarão &lt;code&gt;patterns&lt;/code&gt; em um vetor de strings e farão alguma coisa quando encontrá-lo.&lt;/p&gt;
&lt;p&gt;Como já vimos na sessão sobre regex, a função mais simples que possui o argumento &lt;code&gt;pattern&lt;/code&gt; é a &lt;code&gt;str_detect&lt;/code&gt;.&lt;/p&gt;
&lt;div id=&#34;str_detect&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_detect()`&lt;/h3&gt;
&lt;p&gt;Retorna &lt;code&gt;TRUE&lt;/code&gt; se a regex é compatível com a string e &lt;code&gt;FALSE&lt;/code&gt; caso contrário.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(stringr)
str_detect(&amp;quot;sao paulo&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_detect(&amp;quot;sao paulo sp&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;str_replace-e-str_replace_all&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_replace() e str_replace_all()&lt;/h3&gt;
&lt;p&gt;Substituem um padrão (ou todos) encontrado para um outro padrão&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;frutas &amp;lt;- c(&amp;quot;uma maçã&amp;quot;, &amp;quot;duas pêras&amp;quot;, &amp;quot;três bananas&amp;quot;)
str_replace(frutas, &amp;quot;[aeiou]&amp;quot;, &amp;quot;-&amp;quot;) # substitui a primeira vogal de cada string por &amp;quot;-&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;-ma maçã&amp;quot;     &amp;quot;d-as pêras&amp;quot;   &amp;quot;três b-nanas&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace_all(frutas, &amp;quot;[aeiou]&amp;quot;, &amp;quot;-&amp;quot;) # substitui todas as vogais por &amp;quot;-&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;-m- m-çã&amp;quot;     &amp;quot;d--s pêr-s&amp;quot;   &amp;quot;três b-n-n-s&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;yyyy &amp;lt;- &amp;quot;yyyyy yyyyy ll zz&amp;quot;
str_replace(yyyy, &amp;#39;y+&amp;#39;, &amp;#39;x&amp;#39;) # substitui o primeiro 1 ou mais y&amp;#39;s por x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;x yyyyy ll zz&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace_all(yyyy, &amp;#39;y+&amp;#39;, &amp;#39;x&amp;#39;) # substitui todos os 1 ou mais y por somente 1 x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;x x ll zz&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace_all(yyyy, &amp;#39;y&amp;#39;, &amp;#39;x&amp;#39;) # substitui y por x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;xxxxx xxxxx ll zz&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace_all(&amp;#39;string     com    muitos espaços&amp;#39;, &amp;#39; +&amp;#39;, &amp;#39; &amp;#39;) # tirar espaços extras&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;string com muitos espaços&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Muitas vezes queremos remover alguns caracteres especiais de um texto, mas esses caracteres fazem parte de comandos de regex, por exemplo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;string &amp;lt;- &amp;quot;1 + 2 + 5&amp;quot;
#str_replace_all(string, &amp;quot;+&amp;quot;, &amp;quot;-&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Essa forma retorna um erro, pois a função tenta montar uma regex. Você poderia tentar de outras formas, que não retornariam erro, mas também não retornariam o resultado esperado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace_all(string, &amp;quot; + &amp;quot;, &amp;quot; - &amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;1 + 2 + 5&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nesse caso, use a função &lt;code&gt;fixed&lt;/code&gt; para indicar para o &lt;code&gt;stringr&lt;/code&gt; que você não deseja que o parâmetro seja reconhecido como uma regex.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace_all(string, fixed(&amp;quot;+&amp;quot;), &amp;quot;-&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;1 - 2 - 5&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;str_match-e-str_match_all&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_match() e str_match_all()&lt;/h3&gt;
&lt;p&gt;Extrai pedaços da string identificados pela regex. Caso queira extrair somente a parte identificada, use parênteses.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;frases &amp;lt;- c(&amp;#39;a roupa do rei&amp;#39;, &amp;#39;de roma&amp;#39;, &amp;#39;o rato roeu&amp;#39;)
str_match(frases, &amp;#39;roe&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] 
## [1,] NA   
## [2,] NA   
## [3,] &amp;quot;roe&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_match_all(frases, &amp;#39;ro&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
##      [,1]
## [1,] &amp;quot;ro&amp;quot;
## 
## [[2]]
##      [,1]
## [1,] &amp;quot;ro&amp;quot;
## 
## [[3]]
##      [,1]
## [1,] &amp;quot;ro&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_match(frases, &amp;#39;o (ro)&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]   [,2]
## [1,] NA     NA  
## [2,] NA     NA  
## [3,] &amp;quot;o ro&amp;quot; &amp;quot;ro&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;str_split-e-str_split_fixed&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_split() e str_split_fixed()&lt;/h3&gt;
&lt;p&gt;Separa uma string em várias de acordo com um separador.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;string &amp;lt;- &amp;#39;eu sei, usar virgulas, de forma, perfeita&amp;#39;

str_split(string, &amp;#39;, &amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] &amp;quot;eu sei&amp;quot;        &amp;quot;usar virgulas&amp;quot; &amp;quot;de forma&amp;quot;      &amp;quot;perfeita&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_split(string, &amp;#39;, &amp;#39;, simplify = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]     [,2]            [,3]       [,4]      
## [1,] &amp;quot;eu sei&amp;quot; &amp;quot;usar virgulas&amp;quot; &amp;quot;de forma&amp;quot; &amp;quot;perfeita&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Faz o mesmo que &lt;code&gt;str_split()&lt;/code&gt;, mas separa apenas &lt;code&gt;n&lt;/code&gt; vezes&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_split_fixed(string, &amp;#39;, &amp;#39;, 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]     [,2]            [,3]                
## [1,] &amp;quot;eu sei&amp;quot; &amp;quot;usar virgulas&amp;quot; &amp;quot;de forma, perfeita&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_split_fixed(string, &amp;#39;, &amp;#39;, 4) # igual a str_split(string, simplify = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]     [,2]            [,3]       [,4]      
## [1,] &amp;quot;eu sei&amp;quot; &amp;quot;usar virgulas&amp;quot; &amp;quot;de forma&amp;quot; &amp;quot;perfeita&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;str_subset&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_subset()&lt;/h3&gt;
&lt;p&gt;Retorna somente as strings compatíveis com a regex.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;frases &amp;lt;- c(&amp;#39;a roupa do rei&amp;#39;, &amp;#39;de roma&amp;#39;, &amp;#39;o rato roeu&amp;#39;)
str_subset(frases, &amp;#39;d[eo]&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;a roupa do rei&amp;quot; &amp;quot;de roma&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;É o mesmo que fazer o subset do R e a função &lt;code&gt;str_detect&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;frases[str_detect(frases, &amp;quot;d[eo]&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;a roupa do rei&amp;quot; &amp;quot;de roma&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;untitled&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Untitled&lt;/h1&gt;
&lt;div id=&#34;exercicios&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Exercícios&lt;/h3&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Considere o seguinte texto&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;txt &amp;lt;- &amp;quot;A função mais importante para leitura de dados no `lubridate` é a `ymd`. Essa função serve para ler qualquer data de uma `string` no formato `YYYY-MM-DD`. Essa função é útil pois funciona com qualquer separador entre os elementos da data e também porque temos uma função para cada formato (`mdy`, `dmy`, `dym`, `myd`, `ydm`).&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Extraia todas as combinações da função &lt;code&gt;ymd&lt;/code&gt;, sem repetições.&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Considere os textos abaixo&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;txts &amp;lt;- c(
  &amp;#39;o produto é muito bom&amp;#39;,
  &amp;#39;o produto não é bom&amp;#39;,
  &amp;#39;o produto não é muito bom&amp;#39;,
  &amp;#39;o produto não é ruim&amp;#39;,
  &amp;#39;o produto não é não bom&amp;#39;
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Crie uma regra para identificar se o texto refere-se a um feedback positivo ou negativo sobre o produto (considera não bom = ruim e vice-versa). Retorne um vetor lógico que vale &lt;code&gt;TRUE&lt;/code&gt; se o feedback é positivo e &lt;code&gt;FALSE&lt;/code&gt; caso contrário. #‘index’ ##### str_to_upper, str_to_lower, str_to_title ##str_to_title(s) #### str_to_upper, str_to_lower, str_to_title #str_to_title(s) ##Untitled #Introdução: Stringr&lt;/p&gt;
&lt;p&gt;Variáveis do tipo texto são muito comuns nos bancos de dados e geralmente são colunas que dão bastante trabalho para serem manipuladas. É muito comun encontrar bancos de dados em que os textos de uma coluna não estão padronizados, por exemplo uma coluna &lt;code&gt;Estado&lt;/code&gt; em que são encontrados “SP”, “sp”, “Sao Paulo”, “São Paulo”, etc todas as variações indicando o mesmo estado.&lt;/p&gt;
&lt;p&gt;Para manipular esses textos o R possui diversas funções para manipular textos, no entanto, as funções do &lt;code&gt;base&lt;/code&gt; não possuem um interface consistente e parece que cada uma tem a sua forma de passar os parâmetros, dificultando o processo durante a análise.&lt;/p&gt;
&lt;p&gt;Por isso, é recomendado usar o pacote &lt;code&gt;stringr&lt;/code&gt; que possui a sintaxe consistente permitindo que o usuário realize qualquer manipulação com textos com maior facilidade.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;vantagens-do-stringr-em-relacao-ao-base-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Vantagens do stringr em relação ao base&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sintaxe unificada, o que auxilia na memorização e leitura do código.&lt;/li&gt;
&lt;li&gt;Todas as funções são vetorizadas.&lt;/li&gt;
&lt;li&gt;Construído sobre a &lt;a href=&#34;http://site.icu-project.org/&#34;&gt;biblioteca ICU&lt;/a&gt;, implementada em &lt;code&gt;C&lt;/code&gt; e &lt;code&gt;C++&lt;/code&gt;, apresentando resultados rápidos e confiáveis.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;regras-basicas-do-pacote-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Regras básicas do pacote&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;As funções de manipulação de texto começam com &lt;code&gt;str_&lt;/code&gt;. Caso esqueça o nome de uma função, basta digitar &lt;code&gt;stringr::str_&lt;/code&gt; e apertar &lt;code&gt;TAB&lt;/code&gt; para ver quais são as opções.&lt;/li&gt;
&lt;li&gt;O primeiro argumento da função é sempre uma &lt;code&gt;string&lt;/code&gt; ou um vetor de &lt;code&gt;strings&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;curiosidade-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Curiosidade&lt;/h2&gt;
&lt;p&gt;Inicialmente, o &lt;code&gt;stringr&lt;/code&gt; era um &lt;em&gt;wrapper&lt;/em&gt; de funções do &lt;code&gt;base&lt;/code&gt;. Depois disso, surgiu um novo pacote &lt;code&gt;stringi&lt;/code&gt;, com sintaxe similar ao &lt;code&gt;stringr&lt;/code&gt;, mas funcionando como &lt;em&gt;wrapper&lt;/em&gt; da biblioteca ICU. No entanto, Wickham gostou tanto do pacote &lt;code&gt;stringi&lt;/code&gt; que decidiu reescrever o &lt;code&gt;stringr&lt;/code&gt; como um &lt;em&gt;wrapper&lt;/em&gt; do &lt;code&gt;stringi&lt;/code&gt;. Veja &lt;a href=&#34;https://github.com/tidyverse/stringr/blob/master/NEWS.md&#34;&gt;essa página&lt;/a&gt; para detalhes. #stringr: Básico #### str_to_upper, str_to_lower, str_to_title #str_to_title(s)&lt;/p&gt;
&lt;p&gt;Todas as funções do &lt;code&gt;stringr&lt;/code&gt; começam com o prefixo &lt;code&gt;str&lt;/code&gt;, isso ajuda na hora de encontrar a função que você está procurando. No Rstudio, basta digitar &lt;code&gt;str_&lt;/code&gt; e apertar tab que você verá algo parecido com a imagem a baixo. Você pode ir descendo com as setas do teclado e ver o que cada função faz até encontrar a função que estava procurando.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;./home/travis/build/azeloc/pu.test/figure/str_tab.png&#34; alt=&#34;str_tab&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;str_tab&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Nesta sessão vamos utilizar as funções mais simples do &lt;code&gt;stringr&lt;/code&gt;, depois vamos ensinar um pouco de Regex e em seguida veremos as funções mais avançadas do pacote.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;funcoes-basicas-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Funções básicas&lt;/h2&gt;
&lt;div id=&#34;str_length-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_length&lt;/h3&gt;
&lt;p&gt;A função mais simples do &lt;code&gt;stringr&lt;/code&gt; é a função &lt;code&gt;str_length&lt;/code&gt;. Esta função recebe apenas uma string como argumento e retorna o número de caracteres. Por exemplo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(stringr)
str_length(&amp;quot;olá&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;length(&amp;quot;olá&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Veja &lt;code&gt;str_length&lt;/code&gt; é diferente de &lt;code&gt;length&lt;/code&gt;. O primeiro retorna o número de caracteres e o segundo retorna o comprimento do objeto. Isso fica mais claro no seguinte exemplo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s &amp;lt;- c(&amp;quot;olá mundo&amp;quot;, &amp;quot;olá universo&amp;quot;)
str_length(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  9 12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;length(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora o &lt;code&gt;str_length&lt;/code&gt; retornou um vetor com o número de caracteres de cada elemento do vetor &lt;code&gt;s&lt;/code&gt;, e o &lt;code&gt;length&lt;/code&gt; retornou o comprimento do vetor &lt;code&gt;s&lt;/code&gt;. Note que espaço é considerado como um caractere.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;str_trim-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_trim&lt;/h3&gt;
&lt;p&gt;É muito comum encontrar textos que vêm com espaços a mais, principalmente de dados provenientes de formulários em que cada usuário escreve da forma que prefere.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;string &amp;lt;- &amp;#39;\nessa      string é muito suja       \n&amp;#39;
str_trim(string)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;essa      string é muito suja&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A função &lt;code&gt;str_trim&lt;/code&gt; ajuda removendo os espaços excedetes antes e depois da string.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;str_sub-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_sub&lt;/h3&gt;
&lt;p&gt;As vezes você precisa obter alguma parte fixa de uma string. Por exemplo, as vezes você encontra variáveis com valores da forma:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s &amp;lt;- c(&amp;quot;01-Feminino&amp;quot;, &amp;quot;02-Masculino&amp;quot;, &amp;quot;03-Indefinido&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Você pode querer manipular essa string para retirar obter apenas a parte final da string. Neste caso pode usar a função &lt;code&gt;str_sub&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_sub(s, start = 4) # pegar do quarto até o último caractere&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Feminino&amp;quot;   &amp;quot;Masculino&amp;quot;  &amp;quot;Indefinido&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;É possível obter também apenas os números&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_sub(s, end = 2) # pegar apenas os dois primeiros caracteres&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;01&amp;quot; &amp;quot;02&amp;quot; &amp;quot;03&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Em outros casos você precisa obter os últimos 2 caracteres.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s &amp;lt;- c(&amp;quot;Feminino-01&amp;quot;, &amp;quot;Masculino-02&amp;quot;, &amp;quot;Indefinido-03&amp;quot;)
str_sub(s, end = -4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Feminino&amp;quot;   &amp;quot;Masculino&amp;quot;  &amp;quot;Indefinido&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_sub(s, start = -2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;01&amp;quot; &amp;quot;02&amp;quot; &amp;quot;03&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;É possível também usar os argumentos &lt;code&gt;start&lt;/code&gt; e &lt;code&gt;end&lt;/code&gt; conjuntamente.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s &amp;lt;- c(&amp;quot;__SP__&amp;quot;, &amp;quot;__MG__&amp;quot;, &amp;quot;__RJ__&amp;quot;)
str_sub(s, 3, 4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;SP&amp;quot; &amp;quot;MG&amp;quot; &amp;quot;RJ&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;str_to_upper-str_to_lower-str_to_title-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_to_upper, str_to_lower, str_to_title&lt;/h3&gt;
&lt;p&gt;Essas funções servem para modificar a caixa das letras. Por exemplo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;s &amp;lt;- &amp;quot;Olá, tudo bem?&amp;quot;
str_to_lower(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;olá, tudo bem?&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_to_upper(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;OLÁ, TUDO BEM?&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_to_title(s)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Olá, Tudo Bem?&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Essas são as funções mais simples do pacote &lt;code&gt;stringr&lt;/code&gt; e mão exigem nenhum conhecimento de regex. Note que nenhuma delas possui o parâmetro &lt;code&gt;pattern&lt;/code&gt;, você verá como especificar esse parâmetros nas próximas sessões.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;regex-1&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Regex&lt;/h1&gt;
&lt;p&gt;Trabalhar com textos exige um certo conhecimento de expressões regulares (&lt;em&gt;regex&lt;/em&gt;). &lt;a href=&#34;https://pt.wikipedia.org/wiki/Express%C3%A3o_regular&#34;&gt;Expressões regulares&lt;/a&gt; permitem identificar conjuntos de caracters, palavras, e outros padrões por meio de uma sintaxe concisa.&lt;/p&gt;
&lt;p&gt;O &lt;code&gt;stringr&lt;/code&gt; utiliza regex da forma descrita &lt;a href=&#34;http://www.gagolewski.com/software/stringi/manual/?manpage=stringi-search-regex&#34;&gt;neste documento&lt;/a&gt;. A própria &lt;a href=&#34;https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html&#34;&gt;definição&lt;/a&gt; de regex do R é um ótimo manual.&lt;/p&gt;
&lt;div id=&#34;expressoes-regulares-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Expressões regulares&lt;/h2&gt;
&lt;p&gt;Expressão regular ou &lt;em&gt;regex&lt;/em&gt; é uma sequência concisa de caracteres que representa várias strings. Entender o básico de expressões regulares é indispensável para trabalhar com textos.&lt;/p&gt;
&lt;p&gt;Vamos estudar expressões regulares através de exemplos e com a função &lt;code&gt;str_detect()&lt;/code&gt;. Essa função retorna &lt;code&gt;TRUE&lt;/code&gt; se uma string atende à uma expressão regular e &lt;code&gt;FALSE&lt;/code&gt; em caso contrário.&lt;/p&gt;
&lt;p&gt;Por exemplo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(stringr)
str_detect(&amp;quot;sao paulo&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_detect(&amp;quot;sao paulo sp&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A regex/pattern “paulo&lt;span class=&#34;math inline&#34;&gt;\(&amp;quot; indica que o texto deve ser terminado em &amp;quot;paulo&amp;quot;. Existem diversos de caracteres auxiliares que vão auxiliar na manipulação dos textos, assim como o &amp;quot;\)&lt;/span&gt;” neste caso. É importante notar que sempre que você estiver passando algum valor para o argumento &lt;code&gt;pattern&lt;/code&gt; de qualquer função do &lt;code&gt;stringr&lt;/code&gt; ele o entenderá como uma regex.&lt;/p&gt;
&lt;p&gt;A tabela abaixo mostra a aplicação de seis &lt;code&gt;regex&lt;/code&gt; a seis strings distintas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;testes &amp;lt;- c(&amp;#39;ban&amp;#39;, &amp;#39;banana&amp;#39;, &amp;#39;abandonado&amp;#39;, &amp;#39;pranab anderson&amp;#39;, &amp;#39;BANANA&amp;#39;, 
            &amp;#39;ele levou ban&amp;#39;)

expressoes &amp;lt;- list(
  &amp;#39;ban&amp;#39;, # reconhece tudo que tenha &amp;quot;ban&amp;quot;, mas não ignora case
  &amp;#39;BAN&amp;#39;, # reconhece tudo que tenha &amp;quot;BAN&amp;quot;, mas não ignora case
  regex(&amp;#39;ban&amp;#39;, ignore_case = TRUE), # reconhece tudo que tenha &amp;quot;ban&amp;quot;, ignorando case
  &amp;#39;ban$&amp;#39;, # reconhece apenas o que termina exatamente em &amp;quot;ban&amp;quot;
  &amp;#39;^ban&amp;#39;, # reconhece apenas o que começa exatamente com &amp;quot;ban&amp;quot;
  &amp;#39;b ?an&amp;#39; # reconhece tudo que tenha &amp;quot;ban&amp;quot;, com ou sem espaço entre o &amp;quot;b&amp;quot; e o &amp;quot;a&amp;quot;
)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;quantificadores-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Quantificadores&lt;/h2&gt;
&lt;p&gt;Os caracteres &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; e &lt;code&gt;{x,y}&lt;/code&gt; indicam quantas vezes um padrão se repete:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ey+&lt;/code&gt; significa &lt;code&gt;e&lt;/code&gt; e depois &lt;code&gt;y&lt;/code&gt; “&lt;strong&gt;uma vez&lt;/strong&gt; ou mais”. Por exemplo, reconhece &lt;code&gt;hey&lt;/code&gt;, &lt;code&gt;heyy&lt;/code&gt;, &lt;code&gt;a eyyy&lt;/code&gt;, mas não reconhece &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; nem &lt;code&gt;yy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ey*&lt;/code&gt; significa “&lt;strong&gt;zero vezes&lt;/strong&gt; ou mais”. Por exemplo, reconhece &lt;code&gt;hey&lt;/code&gt;, &lt;code&gt;heyy&lt;/code&gt;, &lt;code&gt;a eyyy&lt;/code&gt; e &lt;code&gt;e&lt;/code&gt;, mas não reconhece &lt;code&gt;y&lt;/code&gt; nem &lt;code&gt;yy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ey{3}&lt;/code&gt; significa “exatamente três vezes”. Por exemplo, reconhece &lt;code&gt;eyyy&lt;/code&gt; e &lt;code&gt;eyyyy&lt;/code&gt;, mas não reconhece &lt;code&gt;eyy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ey{1,3}&lt;/code&gt; significa “entre uma e três vezes”.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para aplicar um quantificador a um conjunto de caracteres, use parênteses. Por exemplo, &lt;code&gt;(ey )+&lt;/code&gt; reconhece &lt;code&gt;ey ey&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conjuntos-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conjuntos&lt;/h2&gt;
&lt;p&gt;Colocando caracteres dentro de &lt;code&gt;[]&lt;/code&gt;, reconhecemos quaisquer caracteres desse conjunto. Alguns exemplos práticos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[Cc]asa&lt;/code&gt; para reconhecer “casa” em maiúsculo ou minúsculo.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9]&lt;/code&gt; para reconhecer somente números. O mesmo vale para letras &lt;code&gt;[a-z]&lt;/code&gt;, &lt;code&gt;[A-Z]&lt;/code&gt;, &lt;code&gt;[a-zA-Z]&lt;/code&gt; etc.&lt;/li&gt;
&lt;li&gt;O símbolo &lt;code&gt;^&lt;/code&gt; dentro do colchete significa negação. Por exemplo, &lt;code&gt;[^0-9]&lt;/code&gt; significa pegar tudo o que não é número.&lt;/li&gt;
&lt;li&gt;O símbolo &lt;code&gt;.&lt;/code&gt; fora do colchete indica “qualquer caractere”, mas dentro do colchete é apenas ponto.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;[[:space:]]+&lt;/code&gt; para reconhecer espaços e &lt;code&gt;[[:punct:]]+&lt;/code&gt; para reconhecer pontuações.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;miscelanea-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Miscelânea&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;abjutils::rm_accent()&lt;/code&gt; para retirar os acentos de um texto.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;|&lt;/code&gt; para opções, por exemplo &lt;code&gt;desfavor|desprov&lt;/code&gt; reconhece tanto “desfavorável” quanto “desprovido”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\n&lt;/code&gt; pula linha, &lt;code&gt;\f&lt;/code&gt; é final da página, &lt;code&gt;\t&lt;/code&gt; é tab. Use &lt;code&gt;\&lt;/code&gt; para transformar caracteres especiais em literais.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tolower()&lt;/code&gt; e &lt;code&gt;toupper()&lt;/code&gt; para mudar o case de uma string.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A lista de possibilidades com expressões regulares é extensa. Um bom lugar para testar o funcionamento de expressões regulares é o &lt;a href=&#34;https://regex101.com/&#34;&gt;regex101&lt;/a&gt;. #stringr: Avançado&lt;/p&gt;
&lt;p&gt;Agora que já vimos as funções básicas do &lt;code&gt;stringr&lt;/code&gt;, e aprendemos um pouco de regex, vamos às funções mais avançadas. Basicmante, essas funções buscarão &lt;code&gt;patterns&lt;/code&gt; em um vetor de strings e farão alguma coisa quando encontrá-lo.&lt;/p&gt;
&lt;p&gt;Como já vimos na sessão sobre regex, a função mais simples que possui o argumento &lt;code&gt;pattern&lt;/code&gt; é a &lt;code&gt;str_detect&lt;/code&gt;.&lt;/p&gt;
&lt;div id=&#34;str_detect-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_detect()`&lt;/h3&gt;
&lt;p&gt;Retorna &lt;code&gt;TRUE&lt;/code&gt; se a regex é compatível com a string e &lt;code&gt;FALSE&lt;/code&gt; caso contrário.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(stringr)
str_detect(&amp;quot;sao paulo&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_detect(&amp;quot;sao paulo sp&amp;quot;, pattern = &amp;quot;paulo$&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;str_replace-e-str_replace_all-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_replace() e str_replace_all()&lt;/h3&gt;
&lt;p&gt;Substituem um padrão (ou todos) encontrado para um outro padrão&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;frutas &amp;lt;- c(&amp;quot;uma maçã&amp;quot;, &amp;quot;duas pêras&amp;quot;, &amp;quot;três bananas&amp;quot;)
str_replace(frutas, &amp;quot;[aeiou]&amp;quot;, &amp;quot;-&amp;quot;) # substitui a primeira vogal de cada string por &amp;quot;-&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;-ma maçã&amp;quot;     &amp;quot;d-as pêras&amp;quot;   &amp;quot;três b-nanas&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace_all(frutas, &amp;quot;[aeiou]&amp;quot;, &amp;quot;-&amp;quot;) # substitui todas as vogais por &amp;quot;-&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;-m- m-çã&amp;quot;     &amp;quot;d--s pêr-s&amp;quot;   &amp;quot;três b-n-n-s&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;yyyy &amp;lt;- &amp;quot;yyyyy yyyyy ll zz&amp;quot;
str_replace(yyyy, &amp;#39;y+&amp;#39;, &amp;#39;x&amp;#39;) # substitui o primeiro 1 ou mais y&amp;#39;s por x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;x yyyyy ll zz&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace_all(yyyy, &amp;#39;y+&amp;#39;, &amp;#39;x&amp;#39;) # substitui todos os 1 ou mais y por somente 1 x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;x x ll zz&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace_all(yyyy, &amp;#39;y&amp;#39;, &amp;#39;x&amp;#39;) # substitui y por x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;xxxxx xxxxx ll zz&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace_all(&amp;#39;string     com    muitos espaços&amp;#39;, &amp;#39; +&amp;#39;, &amp;#39; &amp;#39;) # tirar espaços extras&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;string com muitos espaços&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Muitas vezes queremos remover alguns caracteres especiais de um texto, mas esses caracteres fazem parte de comandos de regex, por exemplo:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;string &amp;lt;- &amp;quot;1 + 2 + 5&amp;quot;
#str_replace_all(string, &amp;quot;+&amp;quot;, &amp;quot;-&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Essa forma retorna um erro, pois a função tenta montar uma regex. Você poderia tentar de outras formas, que não retornariam erro, mas também não retornariam o resultado esperado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace_all(string, &amp;quot; + &amp;quot;, &amp;quot; - &amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;1 + 2 + 5&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nesse caso, use a função &lt;code&gt;fixed&lt;/code&gt; para indicar para o &lt;code&gt;stringr&lt;/code&gt; que você não deseja que o parâmetro seja reconhecido como uma regex.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_replace_all(string, fixed(&amp;quot;+&amp;quot;), &amp;quot;-&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;1 - 2 - 5&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;str_match-e-str_match_all-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_match() e str_match_all()&lt;/h3&gt;
&lt;p&gt;Extrai pedaços da string identificados pela regex. Caso queira extrair somente a parte identificada, use parênteses.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;frases &amp;lt;- c(&amp;#39;a roupa do rei&amp;#39;, &amp;#39;de roma&amp;#39;, &amp;#39;o rato roeu&amp;#39;)
str_match(frases, &amp;#39;roe&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] 
## [1,] NA   
## [2,] NA   
## [3,] &amp;quot;roe&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_match_all(frases, &amp;#39;ro&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
##      [,1]
## [1,] &amp;quot;ro&amp;quot;
## 
## [[2]]
##      [,1]
## [1,] &amp;quot;ro&amp;quot;
## 
## [[3]]
##      [,1]
## [1,] &amp;quot;ro&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_match(frases, &amp;#39;o (ro)&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]   [,2]
## [1,] NA     NA  
## [2,] NA     NA  
## [3,] &amp;quot;o ro&amp;quot; &amp;quot;ro&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;str_split-e-str_split_fixed-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_split() e str_split_fixed()&lt;/h3&gt;
&lt;p&gt;Separa uma string em várias de acordo com um separador.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;string &amp;lt;- &amp;#39;eu sei, usar virgulas, de forma, perfeita&amp;#39;

str_split(string, &amp;#39;, &amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] &amp;quot;eu sei&amp;quot;        &amp;quot;usar virgulas&amp;quot; &amp;quot;de forma&amp;quot;      &amp;quot;perfeita&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_split(string, &amp;#39;, &amp;#39;, simplify = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]     [,2]            [,3]       [,4]      
## [1,] &amp;quot;eu sei&amp;quot; &amp;quot;usar virgulas&amp;quot; &amp;quot;de forma&amp;quot; &amp;quot;perfeita&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Faz o mesmo que &lt;code&gt;str_split()&lt;/code&gt;, mas separa apenas &lt;code&gt;n&lt;/code&gt; vezes&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_split_fixed(string, &amp;#39;, &amp;#39;, 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]     [,2]            [,3]                
## [1,] &amp;quot;eu sei&amp;quot; &amp;quot;usar virgulas&amp;quot; &amp;quot;de forma, perfeita&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str_split_fixed(string, &amp;#39;, &amp;#39;, 4) # igual a str_split(string, simplify = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1]     [,2]            [,3]       [,4]      
## [1,] &amp;quot;eu sei&amp;quot; &amp;quot;usar virgulas&amp;quot; &amp;quot;de forma&amp;quot; &amp;quot;perfeita&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;str_subset-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;str_subset()&lt;/h3&gt;
&lt;p&gt;Retorna somente as strings compatíveis com a regex.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;frases &amp;lt;- c(&amp;#39;a roupa do rei&amp;#39;, &amp;#39;de roma&amp;#39;, &amp;#39;o rato roeu&amp;#39;)
str_subset(frases, &amp;#39;d[eo]&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;a roupa do rei&amp;quot; &amp;quot;de roma&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;É o mesmo que fazer o subset do R e a função &lt;code&gt;str_detect&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;frases[str_detect(frases, &amp;quot;d[eo]&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;a roupa do rei&amp;quot; &amp;quot;de roma&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;untitled-1&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Untitled&lt;/h1&gt;
&lt;div id=&#34;exercicios-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Exercícios&lt;/h3&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Considere o seguinte texto&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;txt &amp;lt;- &amp;quot;A função mais importante para leitura de dados no `lubridate` é a `ymd`. Essa função serve para ler qualquer data de uma `string` no formato `YYYY-MM-DD`. Essa função é útil pois funciona com qualquer separador entre os elementos da data e também porque temos uma função para cada formato (`mdy`, `dmy`, `dym`, `myd`, `ydm`).&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Extraia todas as combinações da função &lt;code&gt;ymd&lt;/code&gt;, sem repetições.&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Considere os textos abaixo&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;txts &amp;lt;- c(
  &amp;#39;o produto é muito bom&amp;#39;,
  &amp;#39;o produto não é bom&amp;#39;,
  &amp;#39;o produto não é muito bom&amp;#39;,
  &amp;#39;o produto não é ruim&amp;#39;,
  &amp;#39;o produto não é não bom&amp;#39;
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Crie uma regra para identificar se o texto refere-se a um feedback positivo ou negativo sobre o produto (considera não bom = ruim e vice-versa). Retorne um vetor lógico que vale &lt;code&gt;TRUE&lt;/code&gt; se o feedback é positivo e &lt;code&gt;FALSE&lt;/code&gt; caso contrário.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;!-- BLOGDOWN-HEAD

&lt;script src=&#34;index_files/htmlwidgets-0.8/htmlwidgets.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;index_files/jquery-1.12.4/jquery.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;index_files/datatables-binding-0.2/datatables.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;index_files/dt-core-1.10.12/css/jquery.dataTables.min.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;link href=&#34;index_files/dt-core-1.10.12/css/jquery.dataTables.extra.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;index_files/dt-core-1.10.12/js/jquery.dataTables.min.js&#34;&gt;&lt;/script&gt;



/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>Introdução</title>
      <link>/rbase/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/rbase/</guid>
      <description>

&lt;p&gt;A linguagem &lt;code&gt;R&lt;/code&gt; é um tanto quanto intuitiva, muita coisa sai do jeito certo no
chute! Para ver um exemplo disso, é interessante começar fazendo do R uma grande calculadora. Tente jogar no console &lt;code&gt;2*2 - (4 + 4)/2&lt;/code&gt;. Pronto. Com essa simples
expressão você já é capaz de imaginar (e certeiramente) como pedir ao R para fazer qualquer tipo de operação aritmética. Lição aprendida!&lt;/p&gt;

&lt;p&gt;Além do mais, as operações e suas precedências são mantidas como na matemática,
ou seja, divisão e multiplicação são calculadas antes da adição e subtração.
E os parênteses nunca são demais!&lt;/p&gt;

&lt;h2 id=&#34;rstudio&#34;&gt;RStudio&lt;/h2&gt;

&lt;p&gt;Talvez você tenha imaginado qual seria o resultado da operação, mas ainda não
tenha conseguido calcular usando o R, porque você não sabe onde digitar aquilo,
por isso vamos apresentar o RStudio.&lt;/p&gt;

&lt;p&gt;O RStudio é um (o melhor) IDE (&lt;em&gt;integrated development environment&lt;/em&gt;) para o R.
E você pode fazer o download &lt;a href=&#34;https://www.rstudio.com/products/rstudio/download3/&#34;&gt;aqui&lt;/a&gt;.
Estamos assumindo que você já instalou o próprio R. Se não instalou, &lt;a href=&#34;https://cloud.r-project.org/&#34;&gt;clique aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Assim que abrir o RStudio você verá a seguinte tela.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;figures/rstudio-editor.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nela estão dispostos &lt;strong&gt;editor&lt;/strong&gt;, &lt;strong&gt;console&lt;/strong&gt;, &lt;strong&gt;environment&lt;/strong&gt; e &lt;strong&gt;output&lt;/strong&gt;.
Normalmente eles vêm nesta ordem, depois você pode organizá-los da forma que
preferir. Preste atenção a todos esses campos durante este tutorial.&lt;/p&gt;

&lt;p&gt;Agora que você já conhece o RStudio, digite a expressão &lt;code&gt;2*2 - (4 + 4)/2&lt;/code&gt; no
&lt;strong&gt;console&lt;/strong&gt; e tecle &lt;code&gt;Enter&lt;/code&gt;. Uma outra forma de chamar uma expressão é escrever
o código no &lt;strong&gt;editor&lt;/strong&gt; e teclar &lt;code&gt;Ctrl + Enter&lt;/code&gt;. Assim o comando é enviado para
o &lt;strong&gt;console&lt;/strong&gt; onde é diretamente executado.&lt;/p&gt;

&lt;h2 id=&#34;usando-o-console&#34;&gt;Usando o console&lt;/h2&gt;

&lt;p&gt;Pelo console é possível executar qualquer comando do R.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;1:30
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
## [24] 24 25 26 27 28 29 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse comando é uma forma simplificada de criar um vetor de inteiros de 1 a 30.
Você pode ignorar esses números que aparecem entre parênteses, na verdade eles
só indicam o índice do primeiro elemento impresso nessa linha.&lt;/p&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
Quando compilamos?
&lt;/p&gt;
&lt;p&gt;
Quem vem de linguagens como o C ou Java, espera que seja necessário compilar o código em texto para o código de máquinas (geralmente um código binário). No R, isso não é necessário. O R é uma linguagem de programação dinâmica que interpreta o seu código enquanto você o executa.
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Se você digitar um comando incompleto, como &lt;code&gt;5 +&lt;/code&gt; e apertar &lt;code&gt;Enter&lt;/code&gt;, o R irá mostrar
um &lt;code&gt;+&lt;/code&gt;, o que não tem nada a ver com somar alguma coisa, e sim significa que o
R está esperando que você complete o seu comando. Termine o seu comando ou aperte
&lt;code&gt;Esc&lt;/code&gt; para recomeçar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 5 -
+ 
+ 5
[1] 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se você digitar um comando que o R não reconhecer, ele irá retornar uma mensagem
de erro. Não entre em pânico. Ele só está avisando que não conseguiu interpretar
o comando. Depois você já pode digitar mais um comando.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 5 % 5
Error: unexpected input in &amp;quot;5 % 5&amp;quot;
&amp;gt; 5 - 5
[1] 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;objetos&#34;&gt;Objetos&lt;/h2&gt;

&lt;p&gt;O R permite que você salve dados guardando estes dentro de um objeto. Um objeto
nada mais é do que um nome, que pode ser utilizado para chamar dados armazenados.
Por exemplo, você pode salvar dados em &lt;code&gt;a&lt;/code&gt;. Sempre que o R encontrar o nome &lt;code&gt;a&lt;/code&gt;
ele o substituirá pelos dados armazenados em &lt;code&gt;a&lt;/code&gt;. Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- 1
a + 1
## [1] 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No Rstudio, quando um objeto é criado, ele começa a aparecer no painel &lt;strong&gt;environment&lt;/strong&gt;. Essa é uma ótima forma de acompanhar todos os objetos que estão
disponíveis no seu &lt;em&gt;environment&lt;/em&gt;. Outro ponto que é importante lembrar aqui é que
o R entende letras maiúsculas e minúsculas, isto é &lt;code&gt;a&lt;/code&gt; é considerado um objeto
diferente de &lt;code&gt;A&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; a
[1] 1
&amp;gt; A
Error: object &#39;A&#39; not found
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#39;admonition note&#39;&gt;
&lt;p class=&#39;admonition-title&#39;&gt;
&lt;- ou = ?
&lt;/p&gt;
&lt;p&gt;
Essa pergunta é comum, e a resposta padrão é: melhor usar &lt;-. No entanto, na maioria dos casos os dois são equivalentes. Portanto, use qual você achar melhor e seja consistente. Uma boa referência é este &lt;a href=&#34;http://pt.stackoverflow.com/a/160092/6036&#34;&gt;link&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;O R substitui os valores de um objeto sem pedir permissão. Então, se você não
deseja sobreescrever o valor de um objeto, não use o mesmo nome.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- 1
a
## [1] 1
a &amp;lt;- 2
a
## [1] 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora, vamos definir um novo objeto no R, chamado &lt;code&gt;vetor&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor &amp;lt;- 1:10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De forma bastante intuitiva, você pode fazer operações com vetores.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor - 1
##  [1] 0 1 2 3 4 5 6 7 8 9
vetor / 2
##  [1] 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0
vetor * 10
##  [1]  10  20  30  40  50  60  70  80  90 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quando você faz &lt;code&gt;vetor - 1&lt;/code&gt;, o R subtrai &lt;code&gt;1&lt;/code&gt; de cada um dos elementos do vetor.
O mesmo acontece quando você faz qualquer operação aritmética com vetores no R.&lt;/p&gt;

&lt;p&gt;Você também pode fazer operações que envolvem mais de um vetor. Exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor * vetor
##  [1]   1   4   9  16  25  36  49  64  81 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Neste caso, o R irá alinhar os dois vetores e multiplicar elemento por elemento.
Isso pode ficar um pouco confuso quando os dois vetores não possuem o mesmo
tamanho:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor2 &amp;lt;- 1:2
vetor2
## [1] 1 2
vetor * vetor2
##  [1]  1  4  3  8  5 12  7 16  9 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora o R alinhou os dois vetores, e como eles não possuiam o mesmo tamanho, ele
foi repetindo o menor vetor até completar o vetor maior. Isso retornaria um warning
se o tamanho do maior não fosse múltiplo do tamanho do vetor menor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; vetor * vetor3
 [1]  1  4  9  4 10 18  7 16 27 10
Warning message:
In vetor * vetor3 :
  longer object length is not a multiple of shorter object length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esse comportamento é chamado de &lt;strong&gt;reciclagem&lt;/strong&gt;. Isso é útil para fazer operações
com os vetores elementos por elementos (vetorizadamente), mas as vezes pode ser
confuso. Com o tempo você aprenderá a se aproveitar desse comportamento.&lt;/p&gt;

&lt;h2 id=&#34;funções&#34;&gt;Funções&lt;/h2&gt;

&lt;p&gt;O R vem com muitas funções implementadas com as quais você pode fazer muitas
tarefas complicadas, como gerar números aleatórios. Geralmente o nome das funções
é bem intuitivo, por exemplo &lt;code&gt;mean&lt;/code&gt; é a função que calcula a média, &lt;code&gt;round&lt;/code&gt; é a
função que arredonda um número, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pi
## [1] 3.141593
round(pi)
## [1] 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para entender melhor o funcionamento das funções no R considere o seguinte exemplo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;die &amp;lt;- 1:6
round(mean(die))
## [1] 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De forma natural, o R executa as funções uma a uma começando por dentro dos parênteses. Neste caso, ele primeiro substituirá &lt;code&gt;die&lt;/code&gt; pelo seu valor, em seguida
irá calcular a média de &lt;code&gt;die&lt;/code&gt; usando a função &lt;code&gt;mean&lt;/code&gt;. Em seguida ele usa a função
&lt;code&gt;round&lt;/code&gt; para arredondar a média de &lt;code&gt;die&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A ilustração abaixo ajuda a entender o que acontece quando você executa &lt;code&gt;round(mean(die))&lt;/code&gt; no R.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;figures/round.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Passamos dados para as funções por meio de argumentos. No R, esses argumentos estão
documentados na página de ajuda de cada uma das funções, que pode ser acessada
digitando &lt;code&gt;help(nome_da_funcao)&lt;/code&gt; ou &lt;code&gt;?nome_da_funcao&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;criando-suas-próprias-funções&#34;&gt;Criando suas próprias funções&lt;/h3&gt;

&lt;p&gt;Apesar de já existirem uma infinidade de funções disponíveis no R, muitas vezes
você deseja criar a sua própria função. Por exemplo, para organizar uma sequência
de funções que são executadas da mesma forma em diversos lugares do seu código.&lt;/p&gt;

&lt;p&gt;Funções no R também são objetos, assim como vetores. A diferença é a forma de
criá-los e de executá-los. Uma nova função pode ser criada da seguinte forma:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_function &amp;lt;- function(x){
  x/2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pronto. Criamos uma função que divido o argumento &lt;code&gt;x&lt;/code&gt; por 2. Você pode ver o
código de qualquer função do R digitando o nome dela no console (sem parênteses no
final).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;my_function
## function(x){
##   x/2
## }
## &amp;lt;environment: 0x1a12980&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;controles-de-fluxo&#34;&gt;Controles de Fluxo&lt;/h2&gt;

&lt;p&gt;O R possui estruturas de controle de fluxo que são importantes na hora de programar
as suas próprias funções e scripts. O seguinte trecho de código só será executado se
o objeto &lt;code&gt;x&lt;/code&gt; for igual a 1.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 2
if(x == 1){
  print(&amp;quot;oi&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 1
if(x == 1){
  print(&amp;quot;oi&amp;quot;)
}
## [1] &amp;quot;oi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A estrutura do &lt;code&gt;if&lt;/code&gt; é bem simples, mas é importante para introduzir a noção de
vetores lógicos no R. Assim como nas funções, o R executa o que está dentro dos
parênteses no &lt;code&gt;if&lt;/code&gt; para depois decidir se executa a expressão dentro de chaves.&lt;/p&gt;

&lt;p&gt;No caso dos exemplos acima, veja que o R executou &lt;code&gt;x == 1&lt;/code&gt; que retorna &lt;code&gt;TRUE&lt;/code&gt;,
um tipo especial de dados no R chamado &lt;strong&gt;logical&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x == 1
## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como o resultado dessa operação foi &lt;code&gt;TRUE&lt;/code&gt;, o R executou o que estava entre chaves.
Isso nos ajuda a pensar em como funcionam as operações lógicas no R, elas sempre
retornam &lt;code&gt;TRUE&lt;/code&gt; ou &lt;code&gt;FALSE&lt;/code&gt; como resultado. O resultado de operações lógicas também
pode ser salvo dentro de objetos do R e em seguiida ser reutilizado em outras
operações. Por exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;a &amp;lt;- x == 1
b &amp;lt;- x == 2
c &amp;lt;- a &amp;amp; (!b)
if(c){
  print(&amp;quot;oi&amp;quot;)
}
## [1] &amp;quot;oi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Isso pode ser bastante útil e ajuda a entender bem como o R funciona.&lt;/p&gt;

&lt;p&gt;Uma outra importante estrutura de controle de fluxo é o &lt;code&gt;for&lt;/code&gt;. No Rm, um laço &lt;code&gt;for&lt;/code&gt;
é escrito da seguinte forma.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;for(i in 1:5){
  print(i)
}
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Veja como é possível utilizar o obejto &lt;code&gt;i&lt;/code&gt; dentro do laço do &lt;code&gt;for&lt;/code&gt;. Para fazer
operações mais úteis usando &lt;code&gt;for&lt;/code&gt;, é necessário entender um pouco sobre &lt;em&gt;subsetting&lt;/em&gt;
no R. Por enquanto vamos apenas usar que dado um vetor &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x[i]&lt;/code&gt; retorna o &lt;em&gt;i-ésimo&lt;/em&gt;
elemento do vetor &lt;code&gt;x&lt;/code&gt;. Note que os índices começam do 1, ao contrário de muitas
outras linguagens em que os índices começam do 0.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vetor &amp;lt;- 30:40
indices &amp;lt;- 1:length(vetor)
for(i in indices){
  print(vetor[i]/2)
}
## [1] 15
## [1] 15.5
## [1] 16
## [1] 16.5
## [1] 17
## [1] 17.5
## [1] 18
## [1] 18.5
## [1] 19
## [1] 19.5
## [1] 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No trecho de código acima, preste atenção no resultado individual de cada uma das
operações para entender como o R funciona. Veja o que é o vetor &lt;code&gt;indices&lt;/code&gt;,
tente rodar &lt;code&gt;vetor[1]&lt;/code&gt; para ver quais são esses resultados intermediários.&lt;/p&gt;

&lt;h2 id=&#34;exercícios&#34;&gt;Exercícios&lt;/h2&gt;

&lt;p&gt;Pratique! Será que você consegue resolver os exercícios abaixo?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Calcule o número de ouro no R.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$$ \frac{1 + \sqrt{5}}{2} $$&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;O que dá divisão de 1 por 0 no R? E -1 por 0?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Quais as diferenças entre &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;NA&lt;/code&gt; e &lt;code&gt;Inf&lt;/code&gt;?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tente mentalmente calcular o que dá a conta &lt;code&gt;5 + 3 * 10 %/% 3 == 15&lt;/code&gt; no R, sem rodar.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Adicionando apenas parênteses, faça a expressão acima retornar o resultado contrário.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;O que acontece se você rodar:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 4
if(x = 4) {
  &#39;isso aqui apareceu&#39;
}
x
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Como você faria para que o código da pergunta anterior fizesse com que &lt;code&gt;&#39;isso aqui apareceu&#39;&lt;/code&gt; fosse impresso no console mas nenhum erro aparecesse?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Difícil&lt;/strong&gt;: Usando &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt; e &lt;code&gt;else&lt;/code&gt; escreva as seguintes frases no console:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;&amp;gt; 1 elefante(s) incomoda(m) muita gente
&amp;gt; 2 elefante(s) incomoda(m) incomoda(m) muito mais
&amp;gt; 3 elefante(s) incomoda(m) muita gente
&amp;gt; 4 elefante(s) incomoda(m) incomoda(m) incomoda(m) incomoda(m) muito mais
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Dica&lt;/em&gt;: Leia o help da função &lt;code&gt;paste&lt;/code&gt; e preste atenção no argumento &lt;code&gt;collapse&lt;/code&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Crie um vetor com o nome &lt;code&gt;x&lt;/code&gt; que contenha os números &lt;code&gt;1, 20, 40, 50, 60&lt;/code&gt; no R.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Crie um vetor com o nome &lt;code&gt;x&lt;/code&gt; de 100 números aleatórios entre 0 e 1.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Calcule a média do vetor criado na questão anterior.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Crie um vetor com 100 elementos. 99 deles são números aleatórios entre 0 e 1 e o último elemento tem o valor &lt;code&gt;NA&lt;/code&gt;. Calcule também a média deste vetor.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;Dica&lt;/em&gt;: Olhe atentamente os argumentos da função &lt;code&gt;mean&lt;/code&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Crie uma função que calcula a média de um vetor. Use &lt;code&gt;for&lt;/code&gt; ou &lt;code&gt;while&lt;/code&gt; nesta função.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Crie uma função que simule um dado, ou seja, gera aleatóriamente um número inteiro entre 1 e 6.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Crie uma função que simula o lançamento de &lt;code&gt;n&lt;/code&gt; dados, e devolve a soma de seus resultados.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Difícil&lt;/strong&gt; Faça um histograma dos resultados da soma de 3 dados. Isto é, crie um vetor com 1000 resultados que aconteceram após somar 3 dados. Em seguida faça o histograma.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Esses exercícios possuem resposta &lt;a href=&#34;https://curso-r.github.io/verao2017/r-como-calculadora/respostas&#34;&gt;aqui&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;ol&gt;
&lt;li&gt;Calcule o número de ouro no R.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$$ \frac{1 + \sqrt{5}}{2} $$&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIERpZ2l0ZSBhIGV4cHJlc3NcdTAwZTNvIHF1ZSBjYWxjdWxhIG8gblx1MDBmYW1lcm8gZGUgb3Vyby5cbiIsInNvbHV0aW9uIjoiIyBEaWdpdGUgYSBleHByZXNzXHUwMGUzbyBxdWUgY2FsY3VsYSBvIG5cdTAwZmFtZXJvIGRlIG91cm8uXG4oMSArIHNxcnQoNSkpLzIiLCJzY3QiOiJ0ZXN0X291dHB1dF9jb250YWlucyhcIjEuNjE4MDM0XCIsIGluY29ycmVjdF9tc2cgPSBcIlRlbSBjZXJ0ZXphIGRlIHF1ZSBpbmRpY291IGEgZXhwcmVzc1x1MDBlM28gY29ycmV0YW1lbnRlP1wiKVxuc3VjY2Vzc19tc2coXCJDb3JyZXRvIVwiKSJ9&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;O que dá divisão de 1 por 0 no R? E -1 por 0?&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIxLzBcbi0xLzAiLCJzY3QiOiJ0ZXN0X291dHB1dF9jb250YWlucyhcIkluZlwiLCBpbmNvcnJlY3RfbXNnID0gXCJUZW0gY2VydGV6YSBkZSBxdWUgaW5kaWNvdSBhIGV4cHJlc3NcdTAwZTNvIGNvcnJldGFtZW50ZT9cIilcbnRlc3Rfb3V0cHV0X2NvbnRhaW5zKFwiLUluZlwiLCBpbmNvcnJlY3RfbXNnID0gXCJUZW0gY2VydGV6YSBkZSBxdWUgaW5kaWNvdSBhIGV4cHJlc3NcdTAwZTNvIGNvcnJldGFtZW50ZT9cIilcbnN1Y2Nlc3NfbXNnKFwiQ29ycmV0byFcIikifQ==&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;Quais as diferenças entre &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;NA&lt;/code&gt; e &lt;code&gt;Inf&lt;/code&gt;? Digite expressões que
retornam cada um desses resultados.&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIE5hTlxuXG4jIE5VTExcblxuIyBOQVxuXG4jIEluZlxuIiwic29sdXRpb24iOiIjIE5hTiBcdTAwZTkgbyByZXN1bHRhZG8gZGUgdW1hIG9wZXJhXHUwMGU3XHUwMGUzbyBtYXRlbVx1MDBlMXRpY2EgaW52XHUwMGUxbGlkYS4gU2lnbmlmaWNhIE5vdCBBIE51bWJlclxuMC8wXG4jIE5VTEwgXHUwMGU5IG8gdmF6aW8gZG8gUi4gXHUwMGM5IGNvbW8gc2UgbyBvYmpldG8gblx1MDBlM28gZXhpc3Rpc3NlXG5OVUxMXG5hID0gTlVMTFxuaXMubnVsbChpbnRlZ2VyKGxlbmd0aCA9IDApKSAjIHZlamEgcXVlIHVtIHZldG9yLCBtZXNtbyBzZW0gZWxlbWVudG9zIG5cdTAwZTNvIFx1MDBlOSBOVUxMXG4jIE5BIFx1MDBlOSB1bWEgY29uc3RhbnRlIGxcdTAwZjNnaWNhIGRvIFIuIFNpZ2luaWZpY2EgTm90IEF2YWlsbGFibGUuIE5BIHBvZGUgc2VyIFxuIyBjb252ZXJ0aWRvIHBhcmEgcXVhc2UgdG9kb3Mgb3MgdGlwb3MgZGUgdmV0b3JlcyBkbyBSLiBcdTAwYzkgdXNhZG8gcHJpbmNpcGFsbWVudGUgcGFyYVxuIyBpbmRpY2FyIHZhbG9yZXMgZmFsdGFudGVzLlxuTkFcbiMgSW5mIFx1MDBlOSBzaWduaWZpY2EgaW5maW5pdG8uIFx1MDBjOSBvIHJlc3VsdGFkbyBkZSBvcGVyYVx1MDBlN1x1MDBmNWVzIG1hdGVtXHUwMGUxdGljYXMgY3VqbyBsaW1pdGUgXHUwMGU5IGluZmluaXRvLlxuMS8wXG4xL0luZiJ9&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Tente mentalmente calcular o que dá a conta &lt;code&gt;5 + 3 * 10 %/% 3 == 15&lt;/code&gt; no R, sem rodar.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Adicionando apenas parênteses, faça a expressão acima retornar o resultado contrário.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI1ICsgMyAqIDEwICUvJSAzID09IDE1Iiwic29sdXRpb24iOiI1ICsgKDMgKiAxMCkgJS8lIDMgPT0gMTUiLCJzY3QiOiJ0ZXN0X291dHB1dF9jb250YWlucyhcIlRSVUVcIiwgaW5jb3JyZWN0X21zZyA9IFwiVGVtIGNlcnRlemEgZGUgcXVlIGluZGljb3UgYSBleHByZXNzXHUwMGUzbyBjb3JyZXRhbWVudGU/XCIpXG5zdWNjZXNzX21zZyhcIkNvcnJldG8hXCIpIn0=&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;O que acontece se você rodar:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- 4
if(x = 4) {
  &#39;isso aqui apareceu&#39;
}
x
&lt;/code&gt;&lt;/pre&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIDRcbmlmKHggPSA0KSB7XG4gICdpc3NvIGFxdWkgYXBhcmVjZXUnXG59XG54In0=&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;Como você faria para que o código da pergunta anterior fizesse com que &lt;code&gt;&#39;isso aqui apareceu&#39;&lt;/code&gt; fosse impresso no console mas nenhum erro aparecesse?&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIDRcbmlmKHggPSA0KSB7XG4gICdpc3NvIGFxdWkgYXBhcmVjZXUnXG59XG54Iiwic29sdXRpb24iOiJ4IDwtIDRcbmlmKHggPT0gNCkge1xuICAnaXNzbyBhcXVpIGFwYXJlY2V1J1xufVxueCIsInNjdCI6InRlc3Rfb3V0cHV0X2NvbnRhaW5zKFwiaXNzbyBhcXVpIGFwYXJlY2V1XCIsIGluY29ycmVjdF9tc2cgPSBcIlRlbSBjZXJ0ZXphIGRlIHF1ZSBpbmRpY291IGEgZXhwcmVzc1x1MDBlM28gY29ycmV0YW1lbnRlP1wiKVxudGVzdF9lcnJvcigpXG5zdWNjZXNzX21zZyhcIkNvcnJldG8hXCIpIn0=&lt;/div&gt;

&lt;script src=&#34;https://cdn.datacamp.com/datacamp-light-latest.min.js&#34;&gt;&lt;/script&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIoMSArIHNxcnQoNSkpLzIifQ==&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIxLzBcbi0xLzAifQ==&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiIjIE5hTiBcdTAwZTkgbyByZXN1bHRhZG8gZGUgdW1hIG9wZXJhXHUwMGU3XHUwMGUzbyBtYXRlbVx1MDBlMXRpY2EgaW52XHUwMGUxbGlkYS4gU2lnbmlmaWNhIE5vdCBBIE51bWJlclxuMC8wXG4jIE5VTEwgXHUwMGU5IG8gdmF6aW8gZG8gUi4gXHUwMGM5IGNvbW8gc2UgbyBvYmpldG8gblx1MDBlM28gZXhpc3Rpc3NlXG5OVUxMXG5hID0gTlVMTFxuaXMubnVsbChpbnRlZ2VyKGxlbmd0aCA9IDApKSAjIHZlamEgcXVlIHVtIHZldG9yLCBtZXNtbyBzZW0gZWxlbWVudG9zIG5cdTAwZTNvIFx1MDBlOSBOVUxMXG4jIE5BIFx1MDBlOSB1bWEgY29uc3RhbnRlIGxcdTAwZjNnaWNhIGRvIFIuIFNpZ2luaWZpY2EgTm90IEF2YWlsbGFibGUuIE5BIHBvZGUgc2VyIFxuIyBjb252ZXJ0aWRvIHBhcmEgcXVhc2UgdG9kb3Mgb3MgdGlwb3MgZGUgdmV0b3JlcyBkbyBSLiBcdTAwYzkgdXNhZG8gcHJpbmNpcGFsbWVudGUgcGFyYVxuIyBpbmRpY2FyIHZhbG9yZXMgZmFsdGFudGVzLlxuTkFcbiMgSW5mIFx1MDBlOSBzaWduaWZpY2EgaW5maW5pdG8uIFx1MDBjOSBvIHJlc3VsdGFkbyBkZSBvcGVyYVx1MDBlN1x1MDBmNWVzIG1hdGVtXHUwMGUxdGljYXMgY3VqbyBsaW1pdGUgXHUwMGU5IGluZmluaXRvLlxuMS8wXG4xL0luZiJ9&lt;/div&gt;

&lt;p&gt;5.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI1ICsgKDMgKiAxMCkgJS8lIDMgPT0gMTUifQ==&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiI+IHggPC0gNFxuPiBpZih4ID0gNCkge1xuRXJybzogJz0nIGluZXNwZXJhZG8gaW4gXCJpZih4ID1cIlxuPiAgICdpc3NvIGFxdWkgYXBhcmVjZXUnXG5bMV0gXCJpc3NvIGFxdWkgYXBhcmVjZXVcIlxuPiB9XG5FcnJvOiAnfScgaW5lc3BlcmFkbyBpbiBcIn1cIlxuPiB4XG5bMV0gNCJ9&lt;/div&gt;

&lt;p&gt;7.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIDRcbmlmKHggPT0gNCkge1xuICAnaXNzbyBhcXVpIGFwYXJlY2V1J1xufVxueCJ9&lt;/div&gt;

&lt;p&gt;8.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJmb3IgKGkgaW4gMTo0KXtcbiAgaWYoaSAlJSAyID09IDApe1xuICAgIHByaW50KHBhc3RlKGksIFwiZWxlZmFudGUocylcIiwgcGFzdGUocmVwKFwiaW5jb21vZGEobSlcIiwgdGltZXMgPSBpKSwgY29sbGFwc2UgPSBcIiBcIiksIFwibXVpdG8gbWFpc1wiKSlcbiAgfSBlbHNlIHtcbiAgIHByaW50KHBhc3RlKGksIFwiZWxlZmFudGUocykgaW5jb21vZGEobSkgbXVpdGEgZ2VudGVcIikpIFxuICB9XG59In0=&lt;/div&gt;

&lt;p&gt;9.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIGMoMSwgMjAsIDQwLCA1MCwgNjApIn0=&lt;/div&gt;

&lt;p&gt;10.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIHJ1bmlmKDEwMCkifQ==&lt;/div&gt;

&lt;p&gt;11.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtZWFuKHgpIn0=&lt;/div&gt;

&lt;p&gt;12.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJ4IDwtIGMocnVuaWYoOTkpLCBOQSlcbm1lYW4oeCwgbmEucm0gPSBUKSJ9&lt;/div&gt;

&lt;p&gt;13.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJtZWRpYSA8LSBmdW5jdGlvbih4KXtcbiAgaSA8LSAxXG4gIHRhbWFuaG8gPC0gbGVuZ3RoKHgpXG4gIHNvbWEgPC0gMFxuICBmb3IoaSBpbiAxOnRhbWFuaG8pe1xuICAgIHNvbWEgPC0gc29tYSArIHhbaV1cbiAgfVxuICByZXR1cm4oc29tYS90YW1hbmhvKVxufSJ9&lt;/div&gt;

&lt;p&gt;14.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJkYWRvIDwtIGZ1bmN0aW9uKCl7XG4gIHNhbXBsZSgxOjYsIDEpXG59In0=&lt;/div&gt;

&lt;p&gt;15.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJzb21hX2RhZG9zIDwtIGZ1bmN0aW9uKG4pe1xuICBzb21hIDwtIDBcbiAgZm9yKGkgaW4gMTpuKXtcbiAgICBzb21hIDwtIHNvbWEgKyBzYW1wbGUoMTo2LCAxKVxuICB9XG4gIHJldHVybihzb21hKVxufSJ9&lt;/div&gt;

&lt;p&gt;16.&lt;/p&gt;

&lt;div data-datacamp-exercise data-height=&#34;300&#34; data-encoded=&#34;true&#34;&gt;eyJsYW5ndWFnZSI6InIiLCJzYW1wbGUiOiJyZXN1bHRhZG9zIDwtIGludGVnZXIobGVuZ3RoID0gMTAwMClcbmZvcihpIGluIDE6MTAwMCl7XG4gIHJlc3VsdGFkb3NbaV0gPC0gc29tYV9kYWRvcygzKVxufVxuaGlzdChyZXN1bHRhZG9zKSJ9&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>PU</title>
      <link>/train2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/train2/</guid>
      <description>&lt;p&gt;Isso é um Power UP&lt;/p&gt;

&lt;p&gt;I LOVE THE WAY U R.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;1 + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plot(1:10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;figures//unnamed-chunk-3-1.png&#34; alt=&#34;plot of chunk unnamed-chunk-3&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
